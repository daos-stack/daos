/**
* (C) Copyright 2018-2022 Intel Corporation.
*
* SPDX-License-Identifier: BSD-2-Clause-Patent
*/

#ifndef NVMECONTROL_H
#define NVMECONTROL_H

#define BUFLEN 1024

/**
 * \brief NVMECONTROL return codes
 */
enum nvme_control_status_code {
	NVMEC_SUCCESS			= 0x0,
	NVMEC_ERR_CHK_SIZE		= 0x1,
	NVMEC_ERR_GET_PCI_DEV		= 0x2,
	NVMEC_ERR_PCI_ADDR_FMT		= 0x3,
	NVMEC_ERR_PCI_ADDR_PARSE	= 0x4,
	NVMEC_ERR_CTRLR_NOT_FOUND	= 0x5,
	NVMEC_ERR_NS_NOT_FOUND		= 0x6,
	NVMEC_ERR_NOT_SUPPORTED		= 0x7,
	NVMEC_ERR_BAD_LBA		= 0x8,
	NVMEC_ERR_ALLOC_IO_QPAIR	= 0x9,
	NVMEC_ERR_NS_ID_UNEXPECTED	= 0xA,
	NVMEC_ERR_NS_WRITE_FAIL		= 0xB,
	NVMEC_ERR_MULTIPLE_ACTIVE_NS	= 0xC,
	NVMEC_ERR_NULL_NS		= 0xD,
	NVMEC_ERR_ALLOC_SEQUENCE_BUF	= 0xE,
	NVMEC_ERR_NO_VMD_CTRLRS		= 0xF,
	NVMEC_ERR_WRITE_TRUNC		= 0x10,
	NVMEC_ERR_CTRLR_DETACH		= 0x11,

	NVMEC_LAST_STATUS_VALUE
};

/**
 * \brief NVMe controller details
 */
struct ctrlr_t {
	char				 model[BUFLEN];
	char				 serial[BUFLEN];
	char				 pci_addr[BUFLEN];
	char				 fw_rev[BUFLEN];
	char				 pci_type[BUFLEN];
	int				 socket_id;
	struct ns_t			*nss;
	struct nvme_stats		*stats;
	struct ctrlr_t			*next;
};

/**
 * \brief NVMe namespace details
 */
struct ns_t {
	uint32_t	id;
	uint64_t	size;
	struct ns_t    *next;
};

/**
 * \brief Result struct for namespace wipe operation containing return code,
 * namespace id, parent controller pci address, info message and link to next
 * list element.
 */
struct wipe_res_t {
	char			 ctrlr_pci_addr[BUFLEN];
	uint32_t		 ns_id;
	int			 rc;
	char			 info[BUFLEN];
	struct wipe_res_t	*next;
};

/**
 * \brief Return containing return code, controllers, namespaces, wwipe
 * results and info message
 */
struct ret_t {
	struct ctrlr_t		*ctrlrs;
	struct wipe_res_t	*wipe_results;
	int			 rc;
	char			 info[BUFLEN];
};

/**
 * Discover NVMe controllers and namespaces, as well as return device health
 * information.
 *
 * \return a pointer to a return struct (ret_t).
 */
struct ret_t *
nvme_discover(void);

/**
 * Wipe NVMe controller namespace LBA-0.
 *
 * Removes any data container structures e.g. blobstore.
 *
 * \param ctrlr_pci_addr PCI address of NVMe controller.
 *
 * \return a pointer to a return struct (ret_t).
 */
struct ret_t *
nvme_wipe_namespaces(void);

/**
 * Format NVMe controller namespace.
 *
 * \param ctrlr_pci_addr PCI address of NVMe controller.
 *
 * \return a pointer to a return struct (ret_t).
 */
struct ret_t *
nvme_format(char *ctrlr_pci_addr);

/**
 * Update NVMe controller firmware.
 *
 * \param ctrlr_pci_addr PCI address of NVMe controller.
 * \param path Local filepath where firmware image is stored.
 * \param slot Identifier of software slot/register to upload to.
 *
 * \return a pointer to a return struct (ret_t).
 */
struct ret_t *
nvme_fwupdate(char *ctrlr_pci_addr, char *path, unsigned int slot);

/**
 * Cleanup allocated memory for controller list generated by probe/attach.
 */
void
nvme_clean_globals(void);

/**
 * Free memory allocated in linked lists attached to the ret_t struct.
 *
 * \param ret A pointer to a return struct (ret_t) needing to be freed.
 */
void
nvme_clean_ret(struct ret_t *ret);

/**
 * Initialize SPDK environment.
 *
 * \param mem_sz size of memory allocated to environment (mb).
 * \param env_ctx environment context string (DPDK).
 * \param nr_pcil size of pcil.
 * \param pcil list of allowed PCI addresses of NVMe controllers.
 *
 * \return a pointer to a return struct (ret_t).
 */
struct ret_t *
daos_spdk_init(int mem_sz, char *env_ctx, size_t nr_pcil, char **pcil);

#endif
