#!/bin/env python
"""Build DAOS Control Plane"""
#pylint: disable=too-many-locals
from __future__ import print_function
import os
from os.path import join, isdir

GO_COMPILER = 'go'
MIN_GO_VERSION = '1.10.0'

def check_dir_exists(path):
    """
    Check if path points to an existing directory. If it is a file but not a
    directory, delete it.
    """
    if not isdir(path):
        # Not a directory - clear out any file
        if os.path.exists(path):
            os.unlink(path)
        return False
    return True

def do_build(env, path, gosrc, cmd):
    """execute a build command"""
    # Link the version-controlled DAOS Go source directory src/control into
    # GOPATH/src/REPOPATH/src/control in the build directory.
    if not check_dir_exists(path):
        os.makedirs(path)
    path = join(path, "control")
    if not check_dir_exists(path):
        os.symlink(gosrc, path)
    return env.Execute(cmd)

def cmd_build(gopath, repopath, cmd):
    """create a command that ensure paths exist before execution"""
    return lambda target, source, env: do_build(env, gopath, repopath, cmd)

def get_install_src_dir(repopath, name):
    """Get the Gopath-based directory to run 'go install' on"""
    return join(repopath, "src", "control", "cmd", name)

def get_install_bin_path(env, name):
    """Get the final installation location for a binary with a given name"""
    return join(env.subst("$PREFIX"), "bin", name)

def get_bin_path(gopath, name):
    """Get the default location of the binary generated by go build"""
    return join(gopath, "bin", name)

#pylint: disable=too-many-arguments
def install_go_bin(denv, gosrc, gopath, libs, name, install_name):
    """
    Build a Go binary whose source is under directory 'name' and install it
    as 'install_name'.
    libs should be a list of scons-built libraries, or None if none are needed.
    """
    # Repository path shared by DAOS Go package import paths
    repopath = join("github.com", "daos-stack", "daos")
    # Go path to DAOS code
    path = join(gopath, "src", repopath, "src")

    bin_path = get_bin_path(gopath, name)
    mod_src = join(gosrc, "cmd", name, "main.go") # Module src
    install_src = get_install_src_dir(repopath, name)
    install_bin = get_install_bin_path(denv, install_name)
    src = [mod_src]
    if libs is not None:
        src.extend(libs)
    denv.Command(bin_path, src,
                 cmd_build(path, gosrc,
                           "go install %s" % install_src))
    denv.InstallAs(install_bin, bin_path)
#pylint: enable=too-many-arguments

def scons():
    """Execute build"""
    Import('env', 'prereqs')

    env.AppendUnique(LIBPATH=[Dir('.')])

    denv = env.Clone()

    # if SPDK_PREFIX differs from PREFIX, copy dir so files can be accessed at
    # runtime
    prefix = denv.subst("$PREFIX")
    sprefix = denv.subst("$SPDK_PREFIX")
    if sprefix not in ["/usr", prefix]:
        for _dir in [join("share", "spdk", "scripts"), join("include", "spdk")]:
            target = join(prefix, _dir)
            if not check_dir_exists(target):
                os.makedirs(target)
                denv.Command(target, join(sprefix, _dir), Copy("$TARGET",
                                                               "$SOURCE"))

    def check_go_version(context):
        """Check GO Version"""
        context.Display('Checking for Go compiler in $PATH... ')
        go_path = context.env.WhereIs(GO_COMPILER)
        if go_path:
            context.Display(go_path + '\n')
        else:
            context.Result(0)
            return 0

        context.Display('Checking %s version... ' % go_path)
        out = os.popen('%s version' % go_path).read()
        if len(out.split(' ')) < 3:
            context.Result('failed to get version from "%s"' % out)
            return 0

        # go version go1.2.3 linux/amd64
        go_version = out.split(' ')[2].replace('go', '')
        if len([x for x, y in
                zip(go_version.split('.'), MIN_GO_VERSION.split('.'))
                if int(x) < int(y)]) > 0:
            context.Result('%s is too old (min supported: %s) '
                           % (go_version, MIN_GO_VERSION))
            return 0
        else:
            context.Result('%s' % go_version)
            return 1

    conf = Configure(denv, custom_tests={'CheckGoVersion': check_go_version})
    # pylint: disable=no-member
    if not conf.CheckGoVersion():
        print('no usable Go compiler found (yum install golang?)')
        exit(1)
    denv = conf.Finish()
    # pylint: enable=no-member

    # GOPATH for SCons builds in the build directory
    gopath = Dir('.').abspath
    # Version-controlled DAOS Go source directory src/control
    gosrc = Dir('.').srcnode().abspath

    denv.Append(GOPATH=[gopath])
    denv.AppendENVPath('GOPATH', denv['GOPATH'])
    denv['ENV']['GOBIN'] = join(gopath, "bin")

    install_go_bin(denv, gosrc, gopath, None, "agent", "daos_agent")
    install_go_bin(denv, gosrc, gopath, None, "dmg", "dmg")
    install_go_bin(denv, gosrc, gopath, None, "daos_admin", "daos_admin")
    install_go_bin(denv, gosrc, gopath, None, "drpc_test", "hello_drpc")

    agentbin = get_bin_path(gopath, "agent")
    dmgbin = get_bin_path(gopath, "dmg")
    adminbin = get_bin_path(gopath, "daos_admin")
    drpcbin = get_bin_path(gopath, "drpc_test")
    AlwaysBuild([agentbin, dmgbin, adminbin, drpcbin])

    senv = denv.Clone()
    prereqs.require(senv, 'pmdk', 'spdk', 'ofi', 'hwloc')

    gospdkpath = join(gosrc, "lib", "spdk")

    # CGO prerequisite libs for go-spdk bindings
    senv.AppendUnique(CPPPATH=[join(gospdkpath, "include")])

    # Link to DPDK static libs
    senv.AppendUnique(LINKFLAGS=['-Wl,--whole-archive', \
                      '-lrte_mempool', '-lrte_mempool_ring', '-lrte_bus_pci', \
                      '-lrte_pci', '-lrte_ring', '-lrte_mbuf', '-lrte_eal', \
                      '-lrte_kvargs', \
                      '-Wl,--no-whole-archive'])

    # hack to avoid building this library with cov compiler for the moment
    compiler = senv.get('COMPILER').lower()
    if compiler == "covc":
        compiler = "gcc"

    nvmecontrol = senv.StaticLibrary(
        "nvme_control",
        join(gospdkpath, "src", "nvme_control.c"),
        CC=compiler, LIBS=['spdk', 'spdk_env_dpdk', 'numa'])

    senv.Install(join(senv.subst("$PREFIX"), "lib64"), nvmecontrol)

    # CGO shell env vars.

    # explicitly link RTE & SPDK libs
    senv.AppendENVPath(
        "CGO_LDFLAGS",
        senv.subst("-L%s -L$SPDK_PREFIX/lib -L$HWLOC_PREFIX/lib"
                   " -L$OFI_PREFIX/lib -L$ISAL_PREFIX/lib $_RPATH" % gopath) + \
                   " -lspdk_env_dpdk -lspdk_thread -lspdk_bdev -lspdk_copy" + \
                   " -lrte_mempool  -lrte_mempool_ring -lrte_bus_pci" + \
                   " -lrte_pci -lrte_ring -lrte_mbuf -lrte_eal -lrte_kvargs" + \
                   " -lspdk_bdev_aio -lspdk_bdev_nvme -lspdk_bdev_malloc" + \
                   " -lspdk_conf -lspdk_blob -lspdk_nvme -lspdk_util" + \
                   " -lspdk_json -lspdk_jsonrpc -lspdk_rpc -lspdk_trace" + \
                   " -lspdk_sock -lspdk_log -lspdk_notify -lspdk_blob_bdev " + \
                   " -lnuma -ldl -lisal")

    senv.AppendENVPath(
        "CGO_CFLAGS",
        senv.subst("-I$SPDK_PREFIX/include -I$HWLOC_PREFIX/include"
                   " -I$OFI_PREFIX/include"))

    # copy setup_spdk.sh script to be executed at daos_server runtime
    senv.Command(join("$PREFIX", "share", "daos", "control", "setup_spdk.sh"),
                 join(gosrc, "server", "init", "setup_spdk.sh"),
                 [Delete("$TARGET"), Copy("$TARGET", "$SOURCE")])

    install_go_bin(senv, gosrc, gopath, [nvmecontrol], "daos_server",
                   "daos_server")

    serverbin = get_bin_path(gopath, "daos_server")
    AlwaysBuild([serverbin,])

if __name__ == "SCons.Script":
    scons()
