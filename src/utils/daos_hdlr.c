/**
 * (C) Copyright 2016-2019 Intel Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * GOVERNMENT LICENSE RIGHTS-OPEN SOURCE SOFTWARE
 * The Government's rights to use, modify, reproduce, release, perform, display,
 * or disclose this software are subject to the terms of the Apache License as
 * provided in Contract No. B609815.
 * Any reproduction of computer software, computer software documentation, or
 * portions thereof marked with this legend must also reproduce the markings.
 */

/* daos_hdlr.c - resource and operation-specific handler functions
 * invoked by daos(8) utility
 */

#define D_LOGFAC	DD_FAC(client)

#include <stdio.h>
#include <dirent.h>
#include <sys/xattr.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/vfs.h>
#include <fcntl.h>
#include <libgen.h>
#include <daos.h>
#include <daos/common.h>
#include <daos/rpc.h>
#include <daos/debug.h>
#include <daos/object.h>

#include "daos_types.h"
#include "daos_api.h"
#include "daos_fs.h"
#include "daos_uns.h"

#include "daos_hdlr.h"

#define DUNS_XATTR_NAME		"user.daos"
#define DUNS_MAX_XATTR_LEN	170
#define DUNS_XATTR_FMT		"DAOS.%s://%36s/%36s/%s/%zu"

/* TODO: implement these pool op functions
 * int pool_list_cont_hdlr(struct cmd_args_s *ap);
 * int pool_stat_hdlr(struct cmd_args_s *ap);
 * int pool_get_prop_hdlr(struct cmd_args_s *ap);
 * int pool_get_attr_hdlr(struct cmd_args_s *ap);
 * int pool_list_attrs_hdlr(struct cmd_args_s *ap);
 */

int
pool_query_hdlr(struct cmd_args_s *ap)
{
	daos_pool_info_t		 pinfo = {0};
	struct daos_pool_space		*ps = &pinfo.pi_space;
	struct daos_rebuild_status	*rstat = &pinfo.pi_rebuild_st;
	int				 i;
	int				rc = 0;
	int				rc2;

	assert(ap != NULL);
	assert(ap->p_op == POOL_QUERY);

	rc = daos_pool_connect(ap->p_uuid, ap->sysname,
			       ap->mdsrv, DAOS_PC_RO, &ap->pool,
			       NULL /* info */, NULL /* ev */);
	if (rc != 0) {
		fprintf(stderr, "failed to connect to pool: %d\n", rc);
		D_GOTO(out, rc);
	}

	pinfo.pi_bits = DPI_ALL;
	rc = daos_pool_query(ap->pool, NULL, &pinfo, NULL, NULL);
	if (rc != 0) {
		fprintf(stderr, "pool query failed: %d\n", rc);
		D_GOTO(out_disconnect, rc);
	}
	D_PRINT("Pool "DF_UUIDF", ntarget=%u, disabled=%u\n",
		DP_UUID(pinfo.pi_uuid), pinfo.pi_ntargets,
		pinfo.pi_ndisabled);

	D_PRINT("Pool space info:\n");
	D_PRINT("- Target(VOS) count:%d\n", ps->ps_ntargets);
	for (i = DAOS_MEDIA_SCM; i < DAOS_MEDIA_MAX; i++) {
		D_PRINT("- %s:\n",
			i == DAOS_MEDIA_SCM ? "SCM" : "NVMe");
		D_PRINT("  Total size: "DF_U64"\n",
			ps->ps_space.s_total[i]);
		D_PRINT("  Free: "DF_U64", min:"DF_U64", max:"DF_U64", "
			"mean:"DF_U64"\n", ps->ps_space.s_free[i],
			ps->ps_free_min[i], ps->ps_free_max[i],
			ps->ps_free_mean[i]);
	}

	if (rstat->rs_errno == 0) {
		char	*sstr;

		if (rstat->rs_version == 0)
			sstr = "idle";
		else if (rstat->rs_done)
			sstr = "done";
		else
			sstr = "busy";

		D_PRINT("Rebuild %s, "DF_U64" objs, "DF_U64" recs\n",
			sstr, rstat->rs_obj_nr, rstat->rs_rec_nr);
	} else {
		D_PRINT("Rebuild failed, rc=%d, status=%d\n",
			rc, rstat->rs_errno);
	}

out_disconnect:
	/* Pool disconnect  in normal and error flows: preserve rc */
	rc2 = daos_pool_disconnect(ap->pool, NULL);
	if (rc2 != 0)
		fprintf(stderr, "Pool disconnect failed : %d\n", rc2);

	if (rc == 0)
		rc = rc2;
out:
	return rc;
}

/* TODO implement the following container op functions
 * all with signatures similar to this:
 * int cont_FN_hdlr(struct cmd_args_s *ap)
 *
 * cont_list_objs_hdlr()
 * int cont_query_hdlr()
 * int cont_stat_hdlr()
 * int cont_get_prop_hdlr()
 * int cont_set_prop_hdlr()
 * int cont_list_attrs_hdlr()
 * int cont_del_attr_hdlr()
 * int cont_get_attr_hdlr()
 * int cont_set_attr_hdlr()
 * int cont_create_snap_hdlr()
 * int cont_list_snaps_hdlr()
 * int cont_destroy_snap_hdlr()
 * int cont_rollback_hdlr()
 */

/* cont_create_hdlr() - create container by UUID */
int
cont_create_hdlr(struct cmd_args_s *ap)
{
	int		rc;

	/** allow creating a POSIX container without a link in the UNS path */
	if (ap->type == DAOS_PROP_CO_LAYOUT_POSIX) {
		dfs_attr_t attr;

		attr.da_id = 0;
		attr.da_oclass_id = ap->oclass;
		attr.da_chunk_size = ap->chunk_size;
		rc = dfs_cont_create(ap->pool, ap->c_uuid, &attr, NULL, NULL);
	} else {
		rc = daos_cont_create(ap->pool, ap->c_uuid, NULL, NULL);
	}

	if (rc != 0) {
		fprintf(stderr, "failed to create container: %d\n", rc);
		return rc;
	}

	fprintf(stdout, "Successfully created container "DF_UUIDF"\n",
		DP_UUID(ap->c_uuid));

	return rc;
}

/* cont_create_uns_hdlr() - create container and link to
 * POSIX filesystem directory or HDF5 file.
 */
int
cont_create_uns_hdlr(struct cmd_args_s *ap)
{
	struct duns_attr_t	dattr = {0};
	char			type[10];
	int			rc;
	const int		RC_PRINT_HELP = 2;

	/* Required: pool UUID, container type, obj class, chunk_size.
	 * Optional: user-specified container UUID.
	 */
	ARGS_VERIFY_PATH_CREATE(ap, err_rc, rc = RC_PRINT_HELP);

	uuid_copy(dattr.da_puuid, ap->p_uuid);
	uuid_copy(dattr.da_cuuid, ap->c_uuid);
	dattr.da_type = ap->type;
	dattr.da_oclass_id = ap->oclass;
	dattr.da_chunk_size = ap->chunk_size;

	rc = duns_create_path(ap->pool, ap->path, &dattr);
	if (rc) {
		fprintf(stderr, "duns_create_path() error: rc=%d\n", rc);
		D_GOTO(err_rc, rc);
	}

	uuid_copy(ap->c_uuid, dattr.da_cuuid);
	daos_unparse_ctype(ap->type, type);
	fprintf(stdout, "Successfully created container "DF_UUIDF" type %s\n",
			DP_UUID(ap->c_uuid), type);

	return 0;

err_rc:
	return rc;
}

int
cont_uns_insert_hdlr(struct cmd_args_s *ap)
{
	struct statfs	stsf;
	int		rc;
	char		*dir;
	char		*base;
	char		*pool;
	char		*cont;
	int		fd;
	int		nfd;
	int		err;

	if (!ap->path) {
		fprintf(stderr,
			"Path not set\n");
		D_GOTO(err_rc, rc = -DER_INVAL);
	}

	base = basename(ap->path);

	/* This function modifies ap->path by inserting a \0 in place of the
	 * last '/' character, so it's important to call basename() before
	 * dirname() or basename will return the name of the parent directory
	 * not the bottom level entry.
	 */
	dir = dirname(ap->path);

	fd = open(dir, O_PATH | O_DIRECTORY);
	if (fd < 0) {
		err = errno;
		fprintf(stderr,
			"Failed to open parent directory %s\n", strerror(err));
		D_GOTO(err_rc, rc = -DER_INVAL);
	}

	rc = fstatfs(fd, &stsf);
	if (rc < 0) {
		err = errno;
		fprintf(stderr,
			"Failed to statfs parent directory %s\n",
			strerror(err));
		D_GOTO(close, rc = -DER_IO);
	}

	/* This should read FUSE_SUPER_MAGIC however this is not exported from
	 * the kernel headers so hard-code the value
	 */
	if (stsf.f_type != 0x65735546) {
		fprintf(stderr,
			"Wrong filesystem type for path\n");
		D_GOTO(close, rc = -DER_INVAL);
	}

	rc = mkdirat(fd, base, 0700);
	if (rc < 0) {
		err = errno;
		fprintf(stderr,
			"Failed to make new directory %s\n", strerror(err));
		D_GOTO(close, rc = daos_errno2der(rc));
	}

	nfd = openat(fd, base, O_RDONLY, O_DIRECTORY);
	if (nfd < 0) {
		err = errno;
		fprintf(stderr,
			"Failed to open new directory %s\n", strerror(err));
		D_GOTO(unlink, rc = -DER_IO);
	}

	pool = DP_UUID(ap->p_uuid);

	rc = fsetxattr(nfd, "user.uns.pool", pool, strlen(pool), XATTR_CREATE);
	if (rc < 0) {
		err = errno;
		fprintf(stderr,
			"Failed to set pool attribute %s\n", strerror(err));
		D_GOTO(close_two, rc = -DER_IO);

	}

	cont = DP_UUID(ap->c_uuid);

	rc = fsetxattr(nfd, "user.uns.container", cont, strlen(cont),
		       XATTR_CREATE);
	if (rc < 0) {
		err = errno;
		fprintf(stderr,
			"Failed to set cont attribute %s\n", strerror(err));
		D_GOTO(close_two, rc = -DER_IO);

	}

	printf("Setup UNS entry point\n");
	return 0;

close_two:
	close(nfd);
unlink:
	unlinkat(fd, base, AT_REMOVEDIR);
close:
	close(fd);
err_rc:
	return rc;
}

int
cont_query_hdlr(struct cmd_args_s *ap)
{
	daos_cont_info_t	cont_info;
	char			oclass[10], type[10];
	int			rc;

	rc = daos_cont_query(ap->cont, &cont_info, NULL, NULL);
	if (rc) {
		fprintf(stderr, "Container query failed, result: %d\n", rc);
		D_GOTO(err_out, rc);
	}

	printf("Pool UUID:\t"DF_UUIDF"\n", DP_UUID(ap->p_uuid));
	printf("Container UUID:\t"DF_UUIDF"\n", DP_UUID(cont_info.ci_uuid));
	printf("Number of snapshots: %i\n", (int)cont_info.ci_nsnapshots);
	printf("Latest Persistent Snapshot: %i\n",
		(int)cont_info.ci_lsnapshot);
	printf("Highest Aggregated Epoch: "DF_U64"\n", cont_info.ci_hae);
	/* TODO: list snapshot epoch numbers, including ~80 column wrap. */

	if (ap->path != NULL) {
		/* cont_op_hdlr() already did resolve_by_path()
		 * all resulting fields should be populated
		 */
		assert(ap->type != DAOS_PROP_CO_LAYOUT_UNKOWN);

		printf("DAOS Unified Namespace Attributes on path %s:\n",
			ap->path);
		daos_unparse_ctype(ap->type, type);
		if (ap->oclass == OC_UNKNOWN)
			strcpy(oclass, "UNKNOWN");
		else
			daos_oclass_id2name(ap->oclass, oclass);
		printf("Container Type:\t%s\n", type);
		printf("Object Class:\t%s\n", oclass);
		printf("Chunk Size:\t%zu\n", ap->chunk_size);
	}

	return 0;

err_out:
	return rc;
}

int
cont_destroy_hdlr(struct cmd_args_s *ap)
{
	int	rc;

	if (ap->path) {
		rc = duns_destroy_path(ap->pool, ap->path);
		if (rc)
			fprintf(stderr, "duns_destroy_path() failed %s (%d)\n",
				ap->path, rc);
		else
			fprintf(stdout, "Successfully destroyed path %s\n",
				ap->path);
		return rc;
	}

	/* TODO: when API supports, change arg 3 to ap->force_destroy. */
	rc = daos_cont_destroy(ap->pool, ap->c_uuid, 1, NULL);
	if (rc != 0)
		fprintf(stderr, "failed to destroy container: %d\n", rc);
	else
		fprintf(stdout, "Successfully destroyed container "
				DF_UUIDF"\n", DP_UUID(ap->c_uuid));

	return rc;
}

int
obj_query_hdlr(struct cmd_args_s *ap)
{
	struct daos_obj_layout *layout;
	int			i;
	int			j;
	int			rc;

	rc = daos_obj_layout_get(ap->cont, ap->oid, &layout);
	if (rc) {
		fprintf(stderr, "daos_obj_layout_get failed, rc: %d\n", rc);
		D_GOTO(out, rc);
	}

	/* Print the object layout */
	fprintf(stdout, "oid: "DF_OID" ver %d grp_nr: %d\n", DP_OID(ap->oid),
		layout->ol_ver, layout->ol_nr);

	for (i = 0; i < layout->ol_nr; i++) {
		struct daos_obj_shard *shard;

		shard = layout->ol_shards[i];
		fprintf(stdout, "grp: %d\n", i);
		for (j = 0; j < shard->os_replica_nr; j++)
			fprintf(stdout, "replica %d %d\n", j,
				shard->os_ranks[j]);
	}

	daos_obj_layout_free(layout);

out:
	return rc;
}
