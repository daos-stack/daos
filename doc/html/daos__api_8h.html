<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DAOS API: daos_cdurf/src/include/daos_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Intel_Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DAOS API
   &#160;<span id="projectnumber">Version 0.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('daos__api_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">daos_api.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="daos__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afb8acd391dfbeecb6895e66a997781ed"><td class="memItemLeft" align="right" valign="top"><a id="afb8acd391dfbeecb6895e66a997781ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DAOS_SNAPSHOT_MAX_LEN</b>&#160;&#160;&#160;128</td></tr>
<tr class="separator:afb8acd391dfbeecb6895e66a997781ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abc4655c8429eff6b7a5637027ec3dbb2"><td class="memItemLeft" align="right" valign="top">d_rank_list_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#abc4655c8429eff6b7a5637027ec3dbb2">daos_rank_list_parse</a> (const char *str, const char *sep)</td></tr>
<tr class="separator:abc4655c8429eff6b7a5637027ec3dbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa010faa2e20eeb3c987b20ad5ab6a31e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#aa010faa2e20eeb3c987b20ad5ab6a31e">daos_pool_connect</a> (const uuid_t uuid, const char *grp, const d_rank_list_t *svc, unsigned int flags, <a class="el" href="structdaos__handle__t.html">daos_handle_t</a> *poh, <a class="el" href="structdaos__pool__info__t.html">daos_pool_info_t</a> *info, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:aa010faa2e20eeb3c987b20ad5ab6a31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2ed9d16fd4f6cc0a9360a3fb8bcdac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a1a2ed9d16fd4f6cc0a9360a3fb8bcdac">daos_pool_disconnect</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> poh, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a1a2ed9d16fd4f6cc0a9360a3fb8bcdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e958dfff1a20560668602575970b591"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a4e958dfff1a20560668602575970b591">daos_pool_local2global</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> poh, d_iov_t *glob)</td></tr>
<tr class="separator:a4e958dfff1a20560668602575970b591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae016a3c4f6ecf41ea2fac16690d27b93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#ae016a3c4f6ecf41ea2fac16690d27b93">daos_pool_global2local</a> (d_iov_t glob, <a class="el" href="structdaos__handle__t.html">daos_handle_t</a> *poh)</td></tr>
<tr class="separator:ae016a3c4f6ecf41ea2fac16690d27b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d32bebaa76e264a8825074b360c2f2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a2d32bebaa76e264a8825074b360c2f2d">daos_cont_local2global</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> coh, d_iov_t *glob)</td></tr>
<tr class="separator:a2d32bebaa76e264a8825074b360c2f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa780e37e03ace1bb78baec4ca2096c75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#aa780e37e03ace1bb78baec4ca2096c75">daos_cont_global2local</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> poh, d_iov_t glob, <a class="el" href="structdaos__handle__t.html">daos_handle_t</a> *coh)</td></tr>
<tr class="separator:aa780e37e03ace1bb78baec4ca2096c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc65f56de518b4437b4218617eedcf6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a2bc65f56de518b4437b4218617eedcf6">daos_pool_query</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> poh, d_rank_list_t *tgts, <a class="el" href="structdaos__pool__info__t.html">daos_pool_info_t</a> *info, <a class="el" href="structdaos__prop__t.html">daos_prop_t</a> *pool_prop, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a2bc65f56de518b4437b4218617eedcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86246adc954cf99778c6d2e59647be7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#ab86246adc954cf99778c6d2e59647be7">daos_pool_query_target</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> poh, d_rank_list_t *tgts, d_rank_list_t *failed, <a class="el" href="structdaos__target__info__t.html">daos_target_info_t</a> *info_list, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:ab86246adc954cf99778c6d2e59647be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560c030cb0736dc59c2dec1a1c905a75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a560c030cb0736dc59c2dec1a1c905a75">daos_pool_list_attr</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> poh, char *buffer, size_t *size, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a560c030cb0736dc59c2dec1a1c905a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4aea52094f634663fd5c34405f5bdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a7b4aea52094f634663fd5c34405f5bdd">daos_pool_get_attr</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> poh, int n, char const *const names[], void *const buffers[], size_t sizes[], <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a7b4aea52094f634663fd5c34405f5bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cd5e2e0a749bbdcc9480b96eb91541"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#aa5cd5e2e0a749bbdcc9480b96eb91541">daos_pool_set_attr</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> poh, int n, char const *const names[], void const *const values[], size_t const sizes[], <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:aa5cd5e2e0a749bbdcc9480b96eb91541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3817d3dcd223893f448a1514eca479a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a3817d3dcd223893f448a1514eca479a4">daos_cont_create</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> poh, const uuid_t uuid, <a class="el" href="structdaos__prop__t.html">daos_prop_t</a> *cont_prop, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a3817d3dcd223893f448a1514eca479a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98252d902cb099c98ebb66e81f0e34de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a98252d902cb099c98ebb66e81f0e34de">daos_cont_open</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> poh, const uuid_t uuid, unsigned int flags, <a class="el" href="structdaos__handle__t.html">daos_handle_t</a> *coh, <a class="el" href="structdaos__cont__info__t.html">daos_cont_info_t</a> *info, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a98252d902cb099c98ebb66e81f0e34de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619e6f50a6272f421a6967d5a54d7686"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a619e6f50a6272f421a6967d5a54d7686">daos_cont_close</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> coh, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a619e6f50a6272f421a6967d5a54d7686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0630e16bf88dc28b6372d5f58dc2e648"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a0630e16bf88dc28b6372d5f58dc2e648">daos_cont_destroy</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> poh, const uuid_t uuid, int force, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a0630e16bf88dc28b6372d5f58dc2e648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe40750c587a6bd761f8735160152e4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#afe40750c587a6bd761f8735160152e4c">daos_cont_query</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> container, <a class="el" href="structdaos__cont__info__t.html">daos_cont_info_t</a> *info, <a class="el" href="structdaos__prop__t.html">daos_prop_t</a> *cont_prop, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:afe40750c587a6bd761f8735160152e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7eefa0f54fdf10306902d5ee1ef8b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a2b7eefa0f54fdf10306902d5ee1ef8b6">daos_cont_list_attr</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> coh, char *buffer, size_t *size, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a2b7eefa0f54fdf10306902d5ee1ef8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bb5e6daaa823d4e06a8ac00846286f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#ac4bb5e6daaa823d4e06a8ac00846286f">daos_cont_get_attr</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> coh, int n, char const *const names[], void *const buffers[], size_t sizes[], <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:ac4bb5e6daaa823d4e06a8ac00846286f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e96331dd7cc4f930938a4bcf146f74e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a0e96331dd7cc4f930938a4bcf146f74e">daos_cont_set_attr</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> coh, int n, char const *const names[], void const *const values[], size_t const sizes[], <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a0e96331dd7cc4f930938a4bcf146f74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa774a851cf98ae75dc7ed075ac4e814b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#aa774a851cf98ae75dc7ed075ac4e814b">daos_cont_alloc_oids</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> coh, daos_size_t num_oids, uint64_t *oid, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:aa774a851cf98ae75dc7ed075ac4e814b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d5e5ebaf5ae854b97785eabc86419a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#aa6d5e5ebaf5ae854b97785eabc86419a">daos_cont_aggregate</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> coh, daos_epoch_t epoch, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:aa6d5e5ebaf5ae854b97785eabc86419a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad009b4e58db4cccc38f3d5a6d5732897"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#ad009b4e58db4cccc38f3d5a6d5732897">daos_cont_rollback</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> coh, daos_epoch_t epoch, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:ad009b4e58db4cccc38f3d5a6d5732897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab4df174d6e1a48b343d0d5a13e7038"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#afab4df174d6e1a48b343d0d5a13e7038">daos_cont_subscribe</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> coh, daos_epoch_t *epoch, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:afab4df174d6e1a48b343d0d5a13e7038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa2756744ae5f6afd756946927126c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a0aa2756744ae5f6afd756946927126c7">daos_cont_create_snap</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> coh, daos_epoch_t *epoch, char *name, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a0aa2756744ae5f6afd756946927126c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e166976d2bbd06192bcdcd47f4d5462"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a7e166976d2bbd06192bcdcd47f4d5462">daos_cont_list_snap</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> coh, int *nr, daos_epoch_t *epochs, char **names, <a class="el" href="structdaos__anchor__t.html">daos_anchor_t</a> *anchor, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a7e166976d2bbd06192bcdcd47f4d5462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794403da19e79aaed193c0ab187951ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a794403da19e79aaed193c0ab187951ed">daos_cont_destroy_snap</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> coh, <a class="el" href="structdaos__epoch__range__t.html">daos_epoch_range_t</a> epr, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a794403da19e79aaed193c0ab187951ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf549ca36164793886c6a525f70ccc9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#adf549ca36164793886c6a525f70ccc9a">daos_tx_open</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> coh, <a class="el" href="structdaos__handle__t.html">daos_handle_t</a> *th, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:adf549ca36164793886c6a525f70ccc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb7e867cfd999985945c5d5e4fedac3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a4cb7e867cfd999985945c5d5e4fedac3">daos_tx_commit</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> th, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a4cb7e867cfd999985945c5d5e4fedac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeed38f424e4808a8343899d650339b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#aeeed38f424e4808a8343899d650339b3">daos_tx_open_snap</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> coh, daos_epoch_t epoch, <a class="el" href="structdaos__handle__t.html">daos_handle_t</a> *th, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:aeeed38f424e4808a8343899d650339b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cf0b9f0976d3173d55b2bce33a91f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a40cf0b9f0976d3173d55b2bce33a91f8">daos_tx_abort</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> th, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:a40cf0b9f0976d3173d55b2bce33a91f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1b2d05cbf0cb9ed6a4dc843d97fb82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#acc1b2d05cbf0cb9ed6a4dc843d97fb82">daos_tx_close</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> th, <a class="el" href="structdaos__event.html">daos_event_t</a> *ev)</td></tr>
<tr class="separator:acc1b2d05cbf0cb9ed6a4dc843d97fb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a50870fb708e8044d112a8ec7af5100"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="daos__api_8h.html#a3a50870fb708e8044d112a8ec7af5100">daos_tx_hdl2epoch</a> (<a class="el" href="structdaos__handle__t.html">daos_handle_t</a> th, daos_epoch_t *epoch)</td></tr>
<tr class="separator:a3a50870fb708e8044d112a8ec7af5100"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>DAOS API methods </p>

<p>Definition in file <a class="el" href="daos__api_8h_source.html">daos_api.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa6d5e5ebaf5ae854b97785eabc86419a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d5e5ebaf5ae854b97785eabc86419a">&sect;&nbsp;</a></span>daos_cont_aggregate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_aggregate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">daos_epoch_t&#160;</td>
          <td class="paramname"><em>epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trigger aggregation to specified epoch</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>Container handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epoch</td><td>Epoch to be aggregated to. Current time will be used when 0 is specified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa774a851cf98ae75dc7ed075ac4e814b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa774a851cf98ae75dc7ed075ac4e814b">&sect;&nbsp;</a></span>daos_cont_alloc_oids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_alloc_oids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">daos_size_t&#160;</td>
          <td class="paramname"><em>num_oids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>oid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a unique set of 64 bit unsigned integers to be used for object ID generation for that container. This is an optional helper function for applications to use to guarantee unique object IDs on the container when more than 1 client are accessing objects on the container. The highest used ID is tracked in the container metadata for future access to that container. This doesn't guarantee that the IDs allocated are sequential; and several ID ranges could be discarded at container close.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>Container open handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_oids</td><td>Number of unique IDs requested. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oid</td><td>starting oid that was allocated up to oid + num_oids. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These values will be returned by <em>ev::ev_error</em> in non-blocking mode: 0 Success -DER_NO_HDL Invalid container open handle -DER_UNREACH Network is unreachable </dd></dl>

</div>
</div>
<a id="a619e6f50a6272f421a6967d5a54d7686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619e6f50a6272f421a6967d5a54d7686">&sect;&nbsp;</a></span>daos_cont_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a container handle. Upon successful completion, the container handle's epoch hold (i.e., if LHE &lt; DAOS_EPOCH_MAX) is released, and any uncommitted updates from the container handle are discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>Container open handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These values will be returned by <em>ev::ev_error</em> in non-blocking mode: 0 Success -DER_UNREACH Network is unreachable -DER_NO_HDL Invalid container handle </dd></dl>

</div>
</div>
<a id="a3817d3dcd223893f448a1514eca479a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3817d3dcd223893f448a1514eca479a4">&sect;&nbsp;</a></span>daos_cont_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>poh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uuid_t&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__prop__t.html">daos_prop_t</a> *&#160;</td>
          <td class="paramname"><em>cont_prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new container with uuid <em>uuid</em> on the storage pool connected by <em>poh</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poh</td><td>Pool connection handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID of the new Container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cont_prop</td><td>Optional, container properties pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These values will be returned by <em>ev::ev_error</em> in non-blocking mode: 0 Success -DER_INVAL Invalid parameter -DER_NO_HDL Invalid pool handle -DER_NO_PERM Permission denied -DER_UNREACH network is unreachable </dd></dl>

</div>
</div>
<a id="a0aa2756744ae5f6afd756946927126c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa2756744ae5f6afd756946927126c7">&sect;&nbsp;</a></span>daos_cont_create_snap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_create_snap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">daos_epoch_t *&#160;</td>
          <td class="paramname"><em>epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a persistent snapshot at the current epoch and return it. The epoch that is returned can be used to create a read only transaction to read data from that persistent snapshot. Optionally the snapshot can be given a name as an attribute which can be retrieved with <a class="el" href="daos__api_8h.html#a7e166976d2bbd06192bcdcd47f4d5462">daos_cont_list_snap()</a>. Name length can't exceed DAOS_SNAPSHOT_MAX_LEN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>Container handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">epoch</td><td>returned epoch of persistent snapshot taken. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Optional null terminated name for snapshot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0630e16bf88dc28b6372d5f58dc2e648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0630e16bf88dc28b6372d5f58dc2e648">&sect;&nbsp;</a></span>daos_cont_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>poh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uuid_t&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a container identified by <em>uuid</em>, all objects within this container will be destroyed as well. If there is at least one container opener, and <em>force</em> is set to zero, then the operation completes with DER_BUSY. Otherwise, the container is destroyed when the operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poh</td><td>Pool connection handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>Container UUID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>Container destroy will return failure if the container is still busy (outstanding open handles). This parameter will force the destroy to proceed even if there is an outstanding open handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. Function will run in blocking mode if <em>ev</em> is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These values will be returned by <em>ev::ev_error</em> in non-blocking mode: 0 Success -DER_NO_PERM Permission denied -DER_UNREACH Network is unreachable -DER_NONEXIST Container is nonexistent -DER_BUSY Pool is busy </dd></dl>

</div>
</div>
<a id="a794403da19e79aaed193c0ab187951ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794403da19e79aaed193c0ab187951ed">&sect;&nbsp;</a></span>daos_cont_destroy_snap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_destroy_snap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__epoch__range__t.html">daos_epoch_range_t</a>&#160;</td>
          <td class="paramname"><em>epr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a snapshot. The epoch corresponding to the snapshot is not discarded, but may be aggregated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>Container handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epr</td><td>Epoch range of snapshots to destroy. If epr_lo == epr_hi delete 1 snapshot at epr_lo/hi. If epr_lo == 0, delete all snapshots &lt;= epr_hi. If epr_hi == DAOS_EPOCH_MAX, delete all snapshots &gt;= epr_lo. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4bb5e6daaa823d4e06a8ac00846286f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bb5e6daaa823d4e06a8ac00846286f">&sect;&nbsp;</a></span>daos_cont_get_attr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_get_attr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>names</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>buffers</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a list of user-defined container attribute values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>Container handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of attributes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>Array of <em>n</em> null-terminated attribute names. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>Array of <em>n</em> buffers to store attribute values. Attribute values larger than corresponding buffer sizes will be truncated. NULL values are permitted and will be treated identical to zero-length buffers, in which case only the sizes of attribute values will be retrieved. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sizes</td><td>[in]: Array of <em>n</em> buffer sizes. [out]: Array of actual sizes of <em>n</em> attribute values, regardless of given buffer sizes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa780e37e03ace1bb78baec4ca2096c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa780e37e03ace1bb78baec4ca2096c75">&sect;&nbsp;</a></span>daos_cont_global2local()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_global2local </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>poh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_iov_t&#160;</td>
          <td class="paramname"><em>glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a> *&#160;</td>
          <td class="paramname"><em>coh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a local container handle for global representation data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poh</td><td>Pool connection handle the container belong to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">glob</td><td>Global (shared) representation of a collective handle to be extracted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coh</td><td>Returned local container handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These values will be returned: non-blocking mode: 0 Success -DER_INVAL Invalid parameter -DER_NO_HDL Pool handle is nonexistent </dd></dl>

</div>
</div>
<a id="a2b7eefa0f54fdf10306902d5ee1ef8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7eefa0f54fdf10306902d5ee1ef8b6">&sect;&nbsp;</a></span>daos_cont_list_attr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_list_attr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List the names of all user-defined container attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>Container handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Buffer containing concatenation of all attribute names, each being null-terminated. No truncation is performed and only full names will be returned. NULL is permitted in which case only the aggregate size will be retrieved. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>[in]: Buffer size. [out]: Aggregate size of all attribute names (excluding terminating null characters), regardless of the actual buffer size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e166976d2bbd06192bcdcd47f4d5462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e166976d2bbd06192bcdcd47f4d5462">&sect;&nbsp;</a></span>daos_cont_list_snap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_list_snap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">daos_epoch_t *&#160;</td>
          <td class="paramname"><em>epochs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__anchor__t.html">daos_anchor_t</a> *&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List all the snapshots of a container and optionally retrieve the snapshot name of each one if it was given at create time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>Container handle </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nr</td><td>[in]: Number of snapshots in epochs and names. [out]: Actual number of snapshots returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">epochs</td><td>preallocated array of epochs to store snapshots. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">names</td><td>preallocated array of names of the snapshots. DAOS_SNAPSHOT_MAX_LEN can be used for each name size if not known. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">anchor</td><td>Hash anchor for the next call, it should be set to zeroes for the first call, it should not be changed by caller between calls. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d32bebaa76e264a8825074b360c2f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d32bebaa76e264a8825074b360c2f2d">&sect;&nbsp;</a></span>daos_cont_local2global()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_local2global </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_iov_t *&#160;</td>
          <td class="paramname"><em>glob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a local container handle to global representation data which can be shared with peer processes. If glob-&gt;iov_buf is set to NULL, the actual size of the global handle is returned through glob-&gt;iov_buf_len. This function does not involve any communication and does not block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>valid local container handle to be shared </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">glob</td><td>pointer to iov of the buffer to store handle information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These values will be returned: non-blocking mode: 0 Success -DER_INVAL Invalid parameter -DER_NO_HDL Container handle is nonexistent -DER_TRUNC Buffer in <em>glob</em> is too short, larger buffer required. In this case the required buffer size is returned through glob-&gt;iov_buf_len. </dd></dl>

</div>
</div>
<a id="a98252d902cb099c98ebb66e81f0e34de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98252d902cb099c98ebb66e81f0e34de">&sect;&nbsp;</a></span>daos_cont_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>poh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uuid_t&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a> *&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__cont__info__t.html">daos_cont_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open an existing container identified by UUID <em>uuid</em>. Upon successful completion, <em>coh</em> and <em>info</em>, both of which shall be allocated by the caller, return the container handle and the latest container information respectively. The resulting container handle has an HCE equal to GHCE, an LHE equal to DAOS_EPOCH_MAX, and an LRE equal to GHCE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poh</td><td>Pool connection handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID to identify container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Open mode, represented by the DAOS_COO_ bits. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coh</td><td>Returned open handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Optional, return container information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These values will be returned by <em>ev::ev_error</em> in non-blocking mode: 0 Success -DER_INVAL Invalid parameter -DER_UNREACH Network is unreachable -DER_NO_PERM Permission denied -DER_NONEXIST Container is nonexistent </dd></dl>

</div>
</div>
<a id="afe40750c587a6bd761f8735160152e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe40750c587a6bd761f8735160152e4c">&sect;&nbsp;</a></span>daos_cont_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__cont__info__t.html">daos_cont_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__prop__t.html">daos_prop_t</a> *&#160;</td>
          <td class="paramname"><em>cont_prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query container information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>Container open handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Returned container information. If <em>info::ci_snapshots</em> is not NULL, epochs of snapshots will be stored in it. If <em>info::ci_snapshots</em> is NULL, number of snapshots will be returned by <em>info::ci_nsnapshots</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cont_prop</td><td>Optional, returned container properties If it is NULL, then needs not query the properties. If cont_prop is non-NULL but its dpp_entries is NULL, will query all pool properties, DAOS internally allocates the needed buffers and assign pointer to dpp_entries. If cont_prop's dpp_nr &gt; 0 and dpp_entries is non-NULL, will query the properties for specific dpe_type(s), DAOS internally allocates the needed buffer for dpe_str or dpe_val_ptr, if the dpe_type with immediate value then will directly assign it to dpe_val. User can free the associated buffer by calling daos_prop_free(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These values will be returned by <em>ev::ev_error</em> in non-blocking mode: 0 Success -DER_INVAL Invalid parameter -DER_UNREACH Network is unreachable -DER_NO_HDL Invalid container handle </dd></dl>

</div>
</div>
<a id="ad009b4e58db4cccc38f3d5a6d5732897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad009b4e58db4cccc38f3d5a6d5732897">&sect;&nbsp;</a></span>daos_cont_rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_rollback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">daos_epoch_t&#160;</td>
          <td class="paramname"><em>epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rollback to a specific persistent snapshot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>Container handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epoch</td><td>Epoch if persistent snapshot to rollback to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e96331dd7cc4f930938a4bcf146f74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e96331dd7cc4f930938a4bcf146f74e">&sect;&nbsp;</a></span>daos_cont_set_attr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_set_attr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>names</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t const&#160;</td>
          <td class="paramname"><em>sizes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create or update a list of user-defined container attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>Container handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of attributes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>Array of <em>n</em> null-terminated attribute names. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Array of <em>n</em> attribute values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>Array of <em>n</em> elements containing the sizes of respective attribute values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afab4df174d6e1a48b343d0d5a13e7038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab4df174d6e1a48b343d0d5a13e7038">&sect;&nbsp;</a></span>daos_cont_subscribe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_cont_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">daos_epoch_t *&#160;</td>
          <td class="paramname"><em>epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subscribe to the container snapshot state. If user specifies a valid epoch, the call will return once a persistent snapshot has been taken at that epoch or a greater one. The epoch value will be updated with that epoch. If multiple snapshots exist at an epoch greater than the one specified, the lowest one will be returned in the epoch value. If the epoch value passed in is 0, this call will return the lowest persistent snapshot on the container, if any exist, otherwise will just wait till a persistent snapshot is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>Container handle </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">epoch</td><td>[in]: Epoch of snapshot to wait for. [out]: epoch of persistent snapshot that was taken. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa010faa2e20eeb3c987b20ad5ab6a31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa010faa2e20eeb3c987b20ad5ab6a31e">&sect;&nbsp;</a></span>daos_pool_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_pool_connect </td>
          <td>(</td>
          <td class="paramtype">const uuid_t&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const d_rank_list_t *&#160;</td>
          <td class="paramname"><em>svc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a> *&#160;</td>
          <td class="paramname"><em>poh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__pool__info__t.html">daos_pool_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect to the DAOS pool identified by UUID <em>uuid</em>. Upon a successful completion, <em>poh</em> returns the pool handle, and <em>info</em> returns the latest pool information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uuid</td><td>UUID to identify a pool. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Process set name of the DAOS servers managing the pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">svc</td><td>Pool service replica ranks, as reported by daos_pool_create(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Connect mode represented by the DAOS_PC_ bits. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">poh</td><td>Returned open handle. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">info</td><td>Optional, returned pool information, see daos_pool_info_bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These values will be returned by <em>ev::ev_error</em> in non-blocking mode: 0 Success -DER_INVAL Invalid parameter -DER_UNREACH Network is unreachable -DER_NO_PERM Permission denied -DER_NONEXIST Pool is nonexistent </dd></dl>

</div>
</div>
<a id="a1a2ed9d16fd4f6cc0a9360a3fb8bcdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2ed9d16fd4f6cc0a9360a3fb8bcdac">&sect;&nbsp;</a></span>daos_pool_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_pool_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>poh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnect from the DAOS pool. It should revoke all the container open handles of this pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poh</td><td>Pool connection handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These values will be returned by <em>ev::ev_error</em> in non-blocking mode: 0 Success -DER_UNREACH Network is unreachable -DER_NO_HDL Invalid pool handle </dd></dl>

</div>
</div>
<a id="a7b4aea52094f634663fd5c34405f5bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4aea52094f634663fd5c34405f5bdd">&sect;&nbsp;</a></span>daos_pool_get_attr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_pool_get_attr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>poh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>names</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>buffers</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a list of user-defined pool attribute values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poh</td><td>Pool handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of attributes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>Array of <em>n</em> null-terminated attribute names. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>Array of <em>n</em> buffers to store attribute values. Attribute values larger than corresponding buffer sizes will be truncated. NULL values are permitted and will be treated identical to zero-length buffers, in which case only the sizes of attribute values will be retrieved. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sizes</td><td>[in]: Array of <em>n</em> buffer sizes. [out]: Array of actual sizes of <em>n</em> attribute values, regardless of given buffer sizes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae016a3c4f6ecf41ea2fac16690d27b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae016a3c4f6ecf41ea2fac16690d27b93">&sect;&nbsp;</a></span>daos_pool_global2local()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_pool_global2local </td>
          <td>(</td>
          <td class="paramtype">d_iov_t&#160;</td>
          <td class="paramname"><em>glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a> *&#160;</td>
          <td class="paramname"><em>poh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a local pool connection for global representation data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">glob</td><td>Global (shared) representation of a collective handle to be extracted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">poh</td><td>Returned local pool connection handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These values will be returned: non-blocking mode: 0 Success -DER_INVAL Invalid parameter </dd></dl>

</div>
</div>
<a id="a560c030cb0736dc59c2dec1a1c905a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560c030cb0736dc59c2dec1a1c905a75">&sect;&nbsp;</a></span>daos_pool_list_attr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_pool_list_attr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>poh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List the names of all user-defined pool attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poh</td><td>Pool handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Buffer containing concatenation of all attribute names, each being null-terminated. No truncation is performed and only full names will be returned. NULL is permitted in which case only the aggregate size will be retrieved. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>[in]: Buffer size. [out]: Aggregate size of all attribute names (excluding terminating null characters), regardless of the actual buffer size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e958dfff1a20560668602575970b591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e958dfff1a20560668602575970b591">&sect;&nbsp;</a></span>daos_pool_local2global()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_pool_local2global </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>poh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_iov_t *&#160;</td>
          <td class="paramname"><em>glob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a local pool connection to global representation data which can be shared with peer processes. If glob-&gt;iov_buf is set to NULL, the actual size of the global handle is returned through glob-&gt;iov_buf_len. This function does not involve any communication and does not block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poh</td><td>Valid local pool connection handle to be shared </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">glob</td><td>Pointer to iov of the buffer to store handle information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These values will be returned: non-blocking mode: 0 Success -DER_INVAL Invalid parameter -DER_NO_HDL Pool handle is nonexistent -DER_TRUNC Buffer in <em>glob</em> is too short, a larger buffer is required. In this case the required buffer size is returned through glob-&gt;iov_buf_len. </dd></dl>

</div>
</div>
<a id="a2bc65f56de518b4437b4218617eedcf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc65f56de518b4437b4218617eedcf6">&sect;&nbsp;</a></span>daos_pool_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_pool_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>poh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_list_t *&#160;</td>
          <td class="paramname"><em>tgts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__pool__info__t.html">daos_pool_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__prop__t.html">daos_prop_t</a> *&#160;</td>
          <td class="paramname"><em>pool_prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query pool information. User should provide at least one of <em>info</em> and <em>tgts</em> as output buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poh</td><td>Pool connection handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tgts</td><td>Optional, returned storage targets in this pool. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">info</td><td>Optional, returned pool information, see daos_pool_info_bit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pool_prop</td><td>Optional, returned pool properties. If it is NULL, then needs not query the properties. If pool_prop is non-NULL but its dpp_entries is NULL, will query all pool properties, DAOS internally allocates the needed buffers and assign pointer to dpp_entries. If pool_prop's dpp_nr &gt; 0 and dpp_entries is non-NULL, will query the properties for specific dpe_type(s), DAOS internally allocates the needed buffer for dpe_str or dpe_val_ptr, if the dpe_type with immediate value then will directly assign it to dpe_val. User can free the associated buffer by calling daos_prop_free(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These values will be returned by <em>ev::ev_error</em> in non-blocking mode: 0 Success -DER_INVAL Invalid parameter -DER_UNREACH Network is unreachable -DER_NO_HDL Invalid pool handle </dd></dl>

</div>
</div>
<a id="ab86246adc954cf99778c6d2e59647be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86246adc954cf99778c6d2e59647be7">&sect;&nbsp;</a></span>daos_pool_query_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_pool_query_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>poh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_list_t *&#160;</td>
          <td class="paramname"><em>tgts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_list_t *&#160;</td>
          <td class="paramname"><em>failed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__target__info__t.html">daos_target_info_t</a> *&#160;</td>
          <td class="paramname"><em>info_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query information of storage targets within a DAOS pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poh</td><td>Pool connection handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tgts</td><td>A list of targets to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">failed</td><td>Optional, buffer to store faulty targets on failure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_list</td><td>Returned storage information of <em>tgts</em>, it is an array and array size must equal to tgts::rl_llen. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>These values will be returned by <em>ev::ev_error</em> in non-blocking mode: 0 Success -DER_INVAL Invalid parameter -DER_NO_HDL Invalid pool handle -DER_UNREACH Network is unreachable -DER_NONEXIST No pool on specified targets </dd></dl>

</div>
</div>
<a id="aa5cd5e2e0a749bbdcc9480b96eb91541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cd5e2e0a749bbdcc9480b96eb91541">&sect;&nbsp;</a></span>daos_pool_set_attr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_pool_set_attr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>poh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>names</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t const&#160;</td>
          <td class="paramname"><em>sizes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create or update a list of user-defined pool attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poh</td><td>Pool handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of attributes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>Array of <em>n</em> null-terminated attribute names. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Array of <em>n</em> attribute values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>Array of <em>n</em> elements containing the sizes of respective attribute values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc4655c8429eff6b7a5637027ec3dbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4655c8429eff6b7a5637027ec3dbb2">&sect;&nbsp;</a></span>daos_rank_list_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">d_rank_list_t* daos_rank_list_parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a rank list from a string with a seprator argument. This is a convenience function to generate the rank list required by <a class="el" href="daos__api_8h.html#aa010faa2e20eeb3c987b20ad5ab6a31e">daos_pool_connect()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string with the rank list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sep</td><td>separator of the ranks in <em>str</em>. dmg uses ":" as the separator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>allocated rank list that user is responsible to free with d_rank_list_free(). </dd></dl>

</div>
</div>
<a id="a40cf0b9f0976d3173d55b2bce33a91f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cf0b9f0976d3173d55b2bce33a91f8">&sect;&nbsp;</a></span>daos_tx_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_tx_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abort all updates on the transaction. The transaction can't be used for future updates anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">th</td><td>Transaction handle to abort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if Success, negative if failed. </dd></dl>

</div>
</div>
<a id="acc1b2d05cbf0cb9ed6a4dc843d97fb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1b2d05cbf0cb9ed6a4dc843d97fb82">&sect;&nbsp;</a></span>daos_tx_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_tx_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close and free the transaction handle. This is a local operation, no RPC involved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">th</td><td>Transaction handle to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if Success, negative if failed. </dd></dl>

</div>
</div>
<a id="a4cb7e867cfd999985945c5d5e4fedac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb7e867cfd999985945c5d5e4fedac3">&sect;&nbsp;</a></span>daos_tx_commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_tx_commit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Commit the transaction on the container it was created with. The transaction can't be used for future updates anymore. If -DER_RESTART was returned, the operations that have been done on this transaction need to be redone with a newer transaction since a conflict was detected with another transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">th</td><td>Transaction handle to commit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if Success, negative if failed. Possible error values include: -DER_NO_HDL invalid transaction handle. -DER_INVAL Invalid parameter -DER_RESTART transaction conflict detected. </dd></dl>

</div>
</div>
<a id="a3a50870fb708e8044d112a8ec7af5100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a50870fb708e8044d112a8ec7af5100">&sect;&nbsp;</a></span>daos_tx_hdl2epoch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_tx_hdl2epoch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">daos_epoch_t *&#160;</td>
          <td class="paramname"><em>epoch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return epoch associated with the transaction handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">th</td><td>Transaction handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">th</td><td>Returned epoch value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if Success, negative if failed. </dd></dl>

</div>
</div>
<a id="adf549ca36164793886c6a525f70ccc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf549ca36164793886c6a525f70ccc9a">&sect;&nbsp;</a></span>daos_tx_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_tx_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a> *&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a transaction on a container handle. This returns a transaction handle that is tagged with the current epoch. The transaction handle can be used for IOs that need to be committed transactionally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>Container handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">th</td><td>Returned transaction handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if Success, negative if failed. </dd></dl>

</div>
</div>
<a id="aeeed38f424e4808a8343899d650339b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeed38f424e4808a8343899d650339b3">&sect;&nbsp;</a></span>daos_tx_open_snap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daos_tx_open_snap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a>&#160;</td>
          <td class="paramname"><em>coh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">daos_epoch_t&#160;</td>
          <td class="paramname"><em>epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__handle__t.html">daos_handle_t</a> *&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaos__event.html">daos_event_t</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a read-only transaction from a snapshot. This does not create the snapshot, but only a read transaction to be able to read from a persistent snapshot in the container. If the user passes an epoch that is not snapshoted, or the snapshot was deleted, reads using that transaction might fail if the epoch was aggregated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coh</td><td>Container handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epoch</td><td>Epoch of snapshot to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">th</td><td>Returned read only transaction handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ev</td><td>Completion event, it is optional and can be NULL. The function will run in blocking mode if <em>ev</em> is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if Success, negative if failed. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_9c173a82f34f4639478102cdbeac41ae.html">daos_cdurf</a></li><li class="navelem"><a class="el" href="dir_d365dddb2ce16b6a782b1bf3381e079a.html">src</a></li><li class="navelem"><a class="el" href="dir_9f6dd4787c26529bd38d2f89983ef641.html">include</a></li><li class="navelem"><a class="el" href="daos__api_8h.html">daos_api.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
