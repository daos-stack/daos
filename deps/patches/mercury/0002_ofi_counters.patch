From 187759c6cd99205c52fc5b77fdb6c2d3536f9021 Mon Sep 17 00:00:00 2001
From: Jerome Soumagne <jerome.soumagne@hpe.com>
Date: Thu, 18 Dec 2025 17:47:03 -0600
Subject: [PATCH 2/3] NA OFI: add counters for monitoring tx/rx/rma/cq counts

Monitor mr and addr counts

NA: add NA_Diag_dump_counters() routine to dump counters
if HG_LOG_LEVEL>=min_debug is set

HG Core: clean up counters

HG util: add ability to remove counters

NA OFI: finalize counters after fabric is closed

HG util: bump minor version
---
 CMakeLists.txt          |   2 +-
 src/mercury.c           |   1 +
 src/mercury_core.c      |  40 ++---
 src/na/CMakeLists.txt   |   5 +
 src/na/na.c             |   9 +
 src/na/na.h             |   6 +
 src/na/na_config.h.in   |   1 +
 src/na/na_ofi.c         | 360 +++++++++++++++++++++++++++++++++-------
 src/util/mercury_dlog.c |  37 ++++-
 src/util/mercury_dlog.h |  18 ++
 src/util/mercury_log.c  |  14 +-
 src/util/mercury_log.h  |   8 +
 src/util/version.txt    |   2 +-
 13 files changed, 413 insertions(+), 90 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index e4e79711..e71944f1 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -192,7 +192,7 @@ endif()
 # Enable diagnostics counters separately from debug.
 #------------------------------------------------------------------------------
 option(MERCURY_ENABLE_COUNTERS "Enable diagnostics counters." OFF)
-if(MERCURY_ENABLE_COUNTERS)
+if(MERCURY_ENABLE_COUNTERS AND NOT WIN32)
   set(HG_HAS_DIAG 1)
 else()
   set(HG_HAS_DIAG 0)
diff --git a/src/mercury.c b/src/mercury.c
index 2c062384..6f0376ee 100644
--- a/src/mercury.c
+++ b/src/mercury.c
@@ -1178,6 +1178,7 @@ HG_Diag_dump_counters(void)
 #ifndef _WIN32
     hg_log_dump_counters(&HG_LOG_OUTLET(hg_diag));
 #endif
+    NA_Diag_dump_counters();
 }
 
 /*---------------------------------------------------------------------------*/
diff --git a/src/mercury_core.c b/src/mercury_core.c
index 97cc4fb2..7abd8a47 100644
--- a/src/mercury_core.c
+++ b/src/mercury_core.c
@@ -185,7 +185,7 @@ struct hg_core_private_class {
     struct hg_core_map rpc_map;               /* RPC Map */
     struct hg_core_more_data_cb more_data_cb; /* More data callbacks */
     na_tag_t request_max_tag;                 /* Max value for tag */
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
     struct hg_core_counters counters; /* Diag counters */
 #endif
     hg_atomic_int32_t n_contexts;  /* Total number of contexts */
@@ -369,7 +369,7 @@ struct hg_core_private_handle {
     uint8_t cookie;               /* Cookie */
     bool multi_recv_copy;         /* Copy on multi-recv */
     bool reuse;                   /* Re-use handle once ref_count is 0 */
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
     bool active;
 #endif
 };
@@ -405,7 +405,7 @@ hg_core_op_type_to_string(enum hg_core_op_type op_type);
 /**
  * Init counters.
  */
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
 static void
 hg_core_counters_init(struct hg_core_counters *hg_core_counters);
 #endif
@@ -447,7 +447,7 @@ hg_core_finalize(struct hg_core_private_class *hg_core_class);
 /**
  * Get counters.
  */
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
 static void
 hg_core_class_get_counters(const struct hg_core_counters *counters,
     struct hg_diag_counters *diag_counters);
@@ -1091,7 +1091,7 @@ hg_core_op_type_to_string(enum hg_core_op_type op_type)
 #endif
 
 /*---------------------------------------------------------------------------*/
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
 static void
 hg_core_counters_init(struct hg_core_counters *hg_core_counters)
 {
@@ -1325,7 +1325,7 @@ hg_core_init(const char *na_info_string, bool na_listen, unsigned int version,
     hg_core_class->init_info.listen = na_listen;
 
     /* Stats / counters */
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
     hg_core_counters_init(&hg_core_class->counters);
 #endif
 
@@ -1521,7 +1521,7 @@ error:
 }
 
 /*---------------------------------------------------------------------------*/
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
 static void
 hg_core_class_get_counters(const struct hg_core_counters *counters,
     struct hg_diag_counters *diag_counters)
@@ -3445,7 +3445,7 @@ hg_core_destroy(struct hg_core_private_handle *hg_core_handle)
         return HG_SUCCESS; /* Cannot free yet */
     }
 
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
     if (hg_core_handle->active) {
         hg_atomic_decr64(HG_CORE_HANDLE_CLASS(hg_core_handle)
                 ->counters.rpc_req_recv_active_count);
@@ -4048,7 +4048,7 @@ hg_core_forward(struct hg_core_private_handle *hg_core_handle,
     hg_core_handle->request_callback = callback;
     hg_core_handle->request_arg = arg;
 
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
     /* Increment counter */
     hg_atomic_incr64(
         HG_CORE_HANDLE_CLASS(hg_core_handle)->counters.rpc_req_sent_count);
@@ -4263,7 +4263,7 @@ hg_core_respond(struct hg_core_private_handle *hg_core_handle,
     hg_core_handle->response_callback = callback;
     hg_core_handle->response_arg = arg;
 
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
     /* Increment counter */
     hg_atomic_incr64(
         HG_CORE_HANDLE_CLASS(hg_core_handle)->counters.rpc_resp_sent_count);
@@ -4499,7 +4499,7 @@ hg_core_recv_input_cb(const struct na_cb_info *callback_info)
     hg_thread_spin_lock(&hg_core_handle_pool->pending_list.lock);
     LIST_REMOVE(hg_core_handle, pending);
     hg_thread_spin_unlock(&hg_core_handle_pool->pending_list.lock);
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
     /* Increment counter */
     hg_atomic_incr64(HG_CORE_HANDLE_CLASS(hg_core_handle)
             ->counters.rpc_req_recv_active_count);
@@ -4608,7 +4608,7 @@ hg_core_multi_recv_input_cb(const struct na_cb_info *callback_info)
         ret = hg_core_handle_pool_get(context->handle_pool, &hg_core_handle);
         HG_CHECK_SUBSYS_HG_ERROR(
             rpc, error, ret, "Could not get handle from pool");
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
         /* Increment counter */
         hg_atomic_incr64(HG_CORE_HANDLE_CLASS(hg_core_handle)
                 ->counters.rpc_req_recv_active_count);
@@ -4665,7 +4665,7 @@ hg_core_multi_recv_input_cb(const struct na_cb_info *callback_info)
                 "Copying multi-recv payload of size %zu for handle (%p)",
                 hg_core_handle->core_handle.in_buf_used,
                 (void *) hg_core_handle);
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
             /* Increment counter */
             hg_atomic_incr64(HG_CORE_CONTEXT_CLASS(context)
                     ->counters.rpc_multi_recv_copy_count);
@@ -4763,7 +4763,7 @@ hg_core_process_input(struct hg_core_private_handle *hg_core_handle)
     uint32_t flags = (uint32_t) hg_atomic_get32(&hg_core_handle->flags);
     hg_return_t ret;
 
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
     /* Increment counter */
     hg_atomic_incr64(hg_core_class->counters.rpc_req_recv_count);
 #endif
@@ -4812,7 +4812,7 @@ hg_core_process_input(struct hg_core_private_handle *hg_core_handle)
             "Handle (%p) expected_count incr to %" PRId32,
             (void *) hg_core_handle, expected_count);
 
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
         /* Increment counter */
         hg_atomic_incr64(hg_core_class->counters.rpc_req_extra_count);
 #endif
@@ -4936,7 +4936,7 @@ hg_core_process_output(struct hg_core_private_handle *hg_core_handle)
     uint32_t flags = (uint32_t) hg_atomic_get32(&hg_core_handle->flags);
     hg_return_t ret;
 
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
     /* Increment counter */
     hg_atomic_incr64(hg_core_class->counters.rpc_resp_recv_count);
 #endif
@@ -4980,7 +4980,7 @@ hg_core_process_output(struct hg_core_private_handle *hg_core_handle)
             "Handle (%p) expected_count incr to %" PRId32,
             (void *) hg_core_handle, expected_count);
 
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
         /* Increment counter */
         hg_atomic_incr64(hg_core_class->counters.rpc_resp_extra_count);
 #endif
@@ -5319,7 +5319,7 @@ hg_core_completion_add(struct hg_core_context *core_context,
     struct hg_core_completion_queue *backfill_queue = &context->backfill_queue;
     int rc;
 
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
     /* Increment counter */
     if (hg_completion_entry->op_type == HG_BULK)
         hg_atomic_incr64(HG_CORE_CONTEXT_CLASS(context)->counters.bulk_count);
@@ -6212,7 +6212,7 @@ hg_return_t
 HG_Core_class_get_counters(const hg_core_class_t *hg_core_class,
     struct hg_diag_counters *diag_counters)
 {
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
     const struct hg_core_private_class *private_class =
         (const struct hg_core_private_class *) hg_core_class;
 #endif
@@ -6222,7 +6222,7 @@ HG_Core_class_get_counters(const hg_core_class_t *hg_core_class,
         HG_INVALID_ARG, "NULL HG core class");
     HG_CHECK_SUBSYS_ERROR(cls, diag_counters == NULL, error, ret,
         HG_INVALID_ARG, "NULL pointer to diag_counters");
-#if defined(HG_HAS_DIAG) && !defined(_WIN32)
+#ifdef HG_HAS_DIAG
     hg_core_class_get_counters(&private_class->counters, diag_counters);
 #else
     HG_LOG_SUBSYS_ERROR(cls, "Counters not supported in current build, please "
diff --git a/src/na/CMakeLists.txt b/src/na/CMakeLists.txt
index 115e70bb..d99ed05d 100644
--- a/src/na/CMakeLists.txt
+++ b/src/na/CMakeLists.txt
@@ -59,6 +59,11 @@ set(NA_BUILD_INCLUDE_DEPENDENCIES
 #------------------------------------------------------------------------------
 # Internal dependencies
 #------------------------------------------------------------------------------
+# Diagnostics counters
+if(HG_HAS_DIAG)
+  set(NA_HAS_DIAG 1)
+endif()
+
 # Multi progress
 if(NOT HG_ALLOW_MULTI_PROGRESS)
   option(NA_ALLOW_MULTI_PROGRESS "Allow concurrent progress on single context." ON)
diff --git a/src/na/na.c b/src/na/na.c
index d54db626..61abf0a3 100644
--- a/src/na/na.c
+++ b/src/na/na.c
@@ -1010,6 +1010,15 @@ NA_Set_log_level(const char *level)
     hg_log_set_subsys_level(NA_SUBSYS_NAME_STRING, hg_log_name_to_level(level));
 }
 
+/*---------------------------------------------------------------------------*/
+void
+NA_Diag_dump_counters(void)
+{
+#ifndef _WIN32
+    hg_log_dump_counters(&HG_LOG_OUTLET(NA_SUBSYS_NAME));
+#endif
+}
+
 /*---------------------------------------------------------------------------*/
 na_context_t *
 NA_Context_create(na_class_t *na_class)
diff --git a/src/na/na.h b/src/na/na.h
index ff65ceb2..3d335fe7 100644
--- a/src/na/na.h
+++ b/src/na/na.h
@@ -153,6 +153,12 @@ NA_Has_opt_feature(
 NA_PUBLIC void
 NA_Set_log_level(const char *level);
 
+/**
+ * Dump diagnostic counters into the existing log stream.
+ */
+NA_PUBLIC void
+NA_Diag_dump_counters(void);
+
 /**
  * Return the name of the NA class.
  *
diff --git a/src/na/na_config.h.in b/src/na/na_config.h.in
index 8468de8c..1419bee6 100644
--- a/src/na/na_config.h.in
+++ b/src/na/na_config.h.in
@@ -85,6 +85,7 @@
 
 /* Build Options */
 #cmakedefine NA_HAS_DEBUG
+#cmakedefine NA_HAS_DIAG
 #cmakedefine NA_HAS_MULTI_PROGRESS
 
 /* HWLOC */
diff --git a/src/na/na_ofi.c b/src/na/na_ofi.c
index 682efe65..d385d279 100644
--- a/src/na/na_ofi.c
+++ b/src/na/na_ofi.c
@@ -262,6 +262,9 @@ static unsigned long const na_ofi_prov_flags[] = {NA_OFI_PROV_TYPES};
 /* Prov info array init count */
 #define NA_OFI_PROV_INFO_COUNT (32)
 
+/* Max counter name length */
+#define NA_OFI_MAX_COUNTER_NAME (64)
+
 /* Address / URI max len */
 #define NA_OFI_MAX_URI_LEN (128)
 
@@ -787,7 +790,6 @@ struct na_ofi_domain {
     hg_atomic_int64_t requested_key; /* Requested key if not FI_MR_PROV_KEY */
     int64_t max_key;                 /* Max key if not FI_MR_PROV_KEY */
     uint64_t max_tag;                /* Max tag from CQ data size */
-    hg_atomic_int32_t mr_reg_count;  /* Number of MR registered */
     bool no_wait;                    /* Wait disabled on domain */
     bool av_auth_key;                /* Use FI_AV_AUTH_KEY */
     bool av_user_id;                 /* Use FI_AV_USER_ID */
@@ -830,15 +832,26 @@ struct na_ofi_verify_info {
     enum na_ofi_prov_type prov_type;    /* Provider type */
 };
 
-/* OFI class */
-struct na_ofi_class {
-    struct na_ofi_addr_pool addr_pool; /* Addr pool                */
-    struct fi_info *fi_info;           /* OFI info                 */
-    struct na_ofi_fabric *fabric;      /* Fabric pointer           */
-    struct na_ofi_domain *domain;      /* Domain pointer           */
-    struct na_ofi_endpoint *endpoint;  /* Endpoint pointer         */
-    struct hg_mem_pool *send_pool;     /* Msg send buf pool        */
-    struct hg_mem_pool *recv_pool;     /* Msg recv buf pool        */
+#ifdef NA_HAS_DIAG
+/* OFI counters */
+struct na_ofi_counters {
+    char tx_count_string[NA_OFI_MAX_COUNTER_NAME];   /* TX count string */
+    char rx_count_string[NA_OFI_MAX_COUNTER_NAME];   /* RX count string */
+    char rma_count_string[NA_OFI_MAX_COUNTER_NAME];  /* RMA count string */
+    char mr_count_string[NA_OFI_MAX_COUNTER_NAME];   /* MR count string */
+    char addr_count_string[NA_OFI_MAX_COUNTER_NAME]; /* Addr count string */
+    char cq_count_string[NA_OFI_MAX_COUNTER_NAME];   /* CQ count string */
+    hg_atomic_int32_t *tx_count;   /* Number of active sends */
+    hg_atomic_int32_t *rx_count;   /* Number of active receives */
+    hg_atomic_int32_t *rma_count;  /* Number of active RMAs */
+    hg_atomic_int32_t *mr_count;   /* Number of active MRs */
+    hg_atomic_int32_t *addr_count; /* Number of addresses inserted */
+    hg_atomic_int32_t *cq_count;   /* Number of CQ events */
+};
+#endif
+
+/* OFI ops */
+struct na_ofi_ops {
     na_return_t (*msg_send_unexpected)(
         struct fid_ep *, const struct na_ofi_msg_info *, void *);
     na_return_t (*msg_recv_unexpected)(
@@ -853,14 +866,29 @@ struct na_ofi_class {
     const char *msg_recv_unexpected_string; /* Error log string */
     const char *msg_send_expected_string;   /* Error log string */
     const char *msg_recv_expected_string;   /* Error log string */
-    unsigned long opt_features;             /* Optional feature flags   */
-    hg_atomic_int32_t n_contexts;           /* Number of context        */
-    unsigned int op_retry_timeout;          /* Retry timeout            */
-    unsigned int op_retry_period;           /* Time elapsed until next retry */
-    uint8_t context_max;                    /* Max number of contexts   */
-    bool no_wait;                           /* Ignore wait object       */
-    bool use_sep;                           /* Use scalable endpoints */
-    bool finalizing;                        /* Class being destroyed    */
+};
+
+/* OFI class */
+struct na_ofi_class {
+    struct na_ofi_addr_pool addr_pool; /* Addr pool                */
+    struct fi_info *fi_info;           /* OFI info                 */
+    struct na_ofi_fabric *fabric;      /* Fabric pointer           */
+    struct na_ofi_domain *domain;      /* Domain pointer           */
+    struct na_ofi_endpoint *endpoint;  /* Endpoint pointer         */
+    struct hg_mem_pool *send_pool;     /* Msg send buf pool        */
+    struct hg_mem_pool *recv_pool;     /* Msg recv buf pool        */
+    struct na_ofi_ops ops;             /* OFI operations           */
+#ifdef NA_HAS_DIAG
+    struct na_ofi_counters counters; /* OFI counters             */
+#endif
+    unsigned long opt_features;    /* Optional feature flags   */
+    hg_atomic_int32_t n_contexts;  /* Number of context        */
+    unsigned int op_retry_timeout; /* Retry timeout            */
+    unsigned int op_retry_period;  /* Time elapsed until next retry */
+    uint8_t context_max;           /* Max number of contexts   */
+    bool no_wait;                  /* Ignore wait object       */
+    bool use_sep;                  /* Use scalable endpoints */
+    bool finalizing;               /* Class being destroyed    */
 };
 
 /********************/
@@ -1145,6 +1173,20 @@ na_ofi_class_alloc(void);
 static na_return_t
 na_ofi_class_free(struct na_ofi_class *na_ofi_class);
 
+#ifdef NA_HAS_DIAG
+/**
+ * Init counters.
+ */
+static void
+na_ofi_counters_init(struct na_ofi_counters *counters, int class_id);
+
+/**
+ * Finalize counters.
+ */
+static void
+na_ofi_counters_finalize(struct na_ofi_counters *counters);
+#endif
+
 /**
  * Configure class parameters from environment variables.
  */
@@ -1762,6 +1804,14 @@ static void
 na_ofi_op_retry_abort_addr(
     struct na_ofi_context *na_ofi_context, fi_addr_t fi_addr, na_return_t ret);
 
+/**
+ * Process counters.
+ */
+#ifdef NA_HAS_DIAG
+static void
+na_ofi_cq_process_counters(struct na_ofi_op_id *na_ofi_op_id);
+#endif
+
 /**
  * Complete operation ID.
  */
@@ -3307,6 +3357,12 @@ na_ofi_addr_map_insert(struct na_ofi_class *na_ofi_class,
                 na_ofi_errno_to_na(-rc),
                 "fi_av_remove(%" PRIu64 ") failed, rc: %d (%s)",
                 na_ofi_addr->fi_addr, rc, fi_strerror(-rc));
+
+#ifdef NA_HAS_DIAG
+            /* Counters */
+            hg_atomic_decr32(na_ofi_class->counters.addr_count);
+#endif
+
             addr_map_exist = true;
         }
     } else {
@@ -3353,6 +3409,11 @@ na_ofi_addr_map_insert(struct na_ofi_class *na_ofi_class,
             addr_str, &addr_str_len),
         rc);
 
+#ifdef NA_HAS_DIAG
+    /* Counters */
+    hg_atomic_incr32(na_ofi_class->counters.addr_count);
+#endif
+
 #if FI_VERSION_GE(FI_COMPILE_VERSION, FI_VERSION(1, 20))
     if (na_ofi_class->domain->av_auth_key) {
         size_t addrlen = sizeof(na_ofi_addr->addr_key.addr);
@@ -3458,6 +3519,11 @@ na_ofi_addr_map_remove(
         "fi_av_remove(%" PRIu64 ") failed, rc: %d (%s)", na_ofi_addr->fi_addr,
         rc, fi_strerror(-rc));
 
+#ifdef NA_HAS_DIAG
+    /* Counters */
+    hg_atomic_decr32(na_ofi_addr->class->counters.addr_count);
+#endif
+
     NA_LOG_SUBSYS_DEBUG(
         addr, "Removed addr for FI addr %" PRIu64, na_ofi_addr->fi_addr);
 
@@ -4229,6 +4295,9 @@ static struct na_ofi_class *
 na_ofi_class_alloc(void)
 {
     struct na_ofi_class *na_ofi_class = NULL;
+#ifdef NA_HAS_DIAG
+    static int class_id = 0;
+#endif
     int rc;
 
     /* Create private data */
@@ -4237,6 +4306,10 @@ na_ofi_class_alloc(void)
         "Could not allocate NA private data class");
     hg_atomic_init32(&na_ofi_class->n_contexts, 0);
 
+#ifdef NA_HAS_DIAG
+    na_ofi_counters_init(&na_ofi_class->counters, class_id++);
+#endif
+
     /* Initialize addr pool */
     rc = hg_thread_spin_init(&na_ofi_class->addr_pool.lock);
     NA_CHECK_SUBSYS_ERROR_NORET(
@@ -4301,6 +4374,11 @@ na_ofi_class_free(struct na_ofi_class *na_ofi_class)
         na_ofi_class->fabric = NULL;
     }
 
+#ifdef NA_HAS_DIAG
+    /* Remove counters */
+    na_ofi_counters_finalize(&na_ofi_class->counters);
+#endif
+
     /* Free info */
     if (na_ofi_class->fi_info)
         na_ofi_freeinfo(na_ofi_class->fi_info);
@@ -4313,6 +4391,50 @@ out:
     return ret;
 }
 
+/*---------------------------------------------------------------------------*/
+#ifdef NA_HAS_DIAG
+static void
+na_ofi_counters_init(struct na_ofi_counters *counters, int class_id)
+{
+    snprintf(counters->tx_count_string, sizeof(counters->tx_count_string),
+        "[%d] na_ofi_tx_count  ", class_id);
+    snprintf(counters->rx_count_string, sizeof(counters->rx_count_string),
+        "[%d] na_ofi_rx_count  ", class_id);
+    snprintf(counters->rma_count_string, sizeof(counters->rma_count_string),
+        "[%d] na_ofi_rma_count ", class_id);
+    snprintf(counters->mr_count_string, sizeof(counters->mr_count_string),
+        "[%d] na_ofi_mr_count  ", class_id);
+    snprintf(counters->addr_count_string, sizeof(counters->addr_count_string),
+        "[%d] na_ofi_addr_count", class_id);
+    snprintf(counters->cq_count_string, sizeof(counters->cq_count_string),
+        "[%d] na_ofi_cq_count  ", class_id);
+    HG_LOG_ADD_COUNTER32(na, &counters->tx_count, counters->tx_count_string,
+        "Number of active sends");
+    HG_LOG_ADD_COUNTER32(na, &counters->rx_count, counters->rx_count_string,
+        "Number of active recvs");
+    HG_LOG_ADD_COUNTER32(na, &counters->rma_count, counters->rma_count_string,
+        "Number of active RMAs");
+    HG_LOG_ADD_COUNTER32(na, &counters->mr_count, counters->mr_count_string,
+        "Number of active MRs");
+    HG_LOG_ADD_COUNTER32(na, &counters->addr_count, counters->addr_count_string,
+        "Number of addresses inserted");
+    HG_LOG_ADD_COUNTER32(na, &counters->cq_count, counters->cq_count_string,
+        "Number of events still in CQ");
+}
+
+/*---------------------------------------------------------------------------*/
+static void
+na_ofi_counters_finalize(struct na_ofi_counters *counters)
+{
+    HG_LOG_DEL_COUNTER32(na, counters->tx_count);
+    HG_LOG_DEL_COUNTER32(na, counters->rx_count);
+    HG_LOG_DEL_COUNTER32(na, counters->rma_count);
+    HG_LOG_DEL_COUNTER32(na, counters->mr_count);
+    HG_LOG_DEL_COUNTER32(na, counters->addr_count);
+    HG_LOG_DEL_COUNTER32(na, counters->cq_count);
+}
+#endif
+
 /*---------------------------------------------------------------------------*/
 static na_return_t
 na_ofi_class_env_config(struct na_ofi_class *na_ofi_class)
@@ -4323,26 +4445,26 @@ na_ofi_class_env_config(struct na_ofi_class *na_ofi_class)
     /* Set unexpected msg callbacks */
     env = getenv("NA_OFI_UNEXPECTED_TAG_MSG");
     if (env == NULL || env[0] == '0' || tolower(env[0]) == 'n') {
-        na_ofi_class->msg_send_unexpected = na_ofi_msg_send;
-        na_ofi_class->msg_send_unexpected_string = "fi_senddata";
-        na_ofi_class->msg_recv_unexpected = na_ofi_msg_recv;
-        na_ofi_class->msg_recv_unexpected_string = "fi_recv";
+        na_ofi_class->ops.msg_send_unexpected = na_ofi_msg_send;
+        na_ofi_class->ops.msg_send_unexpected_string = "fi_senddata";
+        na_ofi_class->ops.msg_recv_unexpected = na_ofi_msg_recv;
+        na_ofi_class->ops.msg_recv_unexpected_string = "fi_recv";
     } else {
         NA_LOG_SUBSYS_DEBUG(cls,
             "NA_OFI_UNEXPECTED_TAG_MSG set to %s, forcing unexpected messages "
             "to use tagged recvs",
             env);
-        na_ofi_class->msg_send_unexpected = na_ofi_tag_send;
-        na_ofi_class->msg_send_unexpected_string = "fi_tsend";
-        na_ofi_class->msg_recv_unexpected = na_ofi_tag_recv;
-        na_ofi_class->msg_recv_unexpected_string = "fi_trecv";
+        na_ofi_class->ops.msg_send_unexpected = na_ofi_tag_send;
+        na_ofi_class->ops.msg_send_unexpected_string = "fi_tsend";
+        na_ofi_class->ops.msg_recv_unexpected = na_ofi_tag_recv;
+        na_ofi_class->ops.msg_recv_unexpected_string = "fi_trecv";
     }
 
     /* Set expected msg callbacks */
-    na_ofi_class->msg_send_expected = na_ofi_tag_send;
-    na_ofi_class->msg_send_expected_string = "fi_tsend";
-    na_ofi_class->msg_recv_expected = na_ofi_tag_recv;
-    na_ofi_class->msg_recv_expected_string = "fi_trecv";
+    na_ofi_class->ops.msg_send_expected = na_ofi_tag_send;
+    na_ofi_class->ops.msg_send_expected_string = "fi_tsend";
+    na_ofi_class->ops.msg_recv_expected = na_ofi_tag_recv;
+    na_ofi_class->ops.msg_recv_expected_string = "fi_trecv";
 
     /* Default retry timeouts in ms */
     if ((env = getenv("NA_OFI_OP_RETRY_TIMEOUT")) != NULL) {
@@ -5073,7 +5195,6 @@ na_ofi_domain_open(const struct na_ofi_fabric *na_ofi_fabric,
     hg_atomic_init64(&na_ofi_domain->requested_key, 0);
     /* No need to take a refcount on fabric */
     na_ofi_domain->fabric = na_ofi_fabric;
-    hg_atomic_init32(&na_ofi_domain->mr_reg_count, 0);
 
     /* Dup name */
     na_ofi_domain->name = strdup(domain_attr->name);
@@ -6056,6 +6177,11 @@ na_ofi_mem_buf_register(const void *buf, size_t len, unsigned long flags,
 
     /* Register memory if FI_MR_LOCAL is set and provider uses it */
     if (na_ofi_class->fi_info->domain_attr->mr_mode & FI_MR_LOCAL) {
+#ifdef NA_HAS_DIAG
+        int32_t mr_cnt = hg_atomic_get32(na_ofi_class->counters.mr_count);
+#else
+        int32_t mr_cnt = -1;
+#endif
         struct fid_mr *mr_hdl = NULL;
         uint64_t access = 0;
         int rc;
@@ -6072,10 +6198,11 @@ na_ofi_mem_buf_register(const void *buf, size_t len, unsigned long flags,
         NA_CHECK_SUBSYS_ERROR(mem, rc != 0, out, ret, HG_UTIL_FAIL,
             "fi_mr_reg(buf=%p, len=%zu, flags=%lu) failed, rc: %d (%s), "
             "mr_reg_count: %d",
-            buf, len, flags, rc, fi_strerror(-rc),
-            hg_atomic_get32(&na_ofi_class->domain->mr_reg_count));
+            buf, len, flags, rc, fi_strerror(-rc), mr_cnt);
 
-        hg_atomic_incr32(&na_ofi_class->domain->mr_reg_count);
+#ifdef NA_HAS_DIAG
+        hg_atomic_incr32(na_ofi_class->counters.mr_count);
+#endif
         *handle_p = (void *) mr_hdl;
     } else
         *handle_p = NULL;
@@ -6093,11 +6220,17 @@ na_ofi_mem_buf_deregister(void *handle, void *arg)
     /* Release MR handle is there was any */
     if (handle) {
         struct fid_mr *mr_hdl = (struct fid_mr *) handle;
+#ifdef NA_HAS_DIAG
         struct na_ofi_class *na_ofi_class = (struct na_ofi_class *) arg;
+#else
+        (void) arg;
+#endif
         int rc = fi_close(&mr_hdl->fid);
         NA_CHECK_SUBSYS_ERROR(mem, rc != 0, out, ret, HG_UTIL_FAIL,
             "fi_close() mr_hdl failed, rc: %d (%s)", rc, fi_strerror(-rc));
-        hg_atomic_decr32(&na_ofi_class->domain->mr_reg_count);
+#ifdef NA_HAS_DIAG
+        hg_atomic_decr32(na_ofi_class->counters.mr_count);
+#endif
     }
 
 out:
@@ -6159,6 +6292,11 @@ na_ofi_msg_send_common(struct na_ofi_class *na_ofi_class,
     if ((int) na_ofi_class->fi_info->addr_format == FI_ADDR_OPX)
         na_ofi_op_id->fi_ctx[0].internal[0] = &na_ofi_addr->addr_key.addr.opx;
 
+#ifdef NA_HAS_DIAG
+    /* Counters */
+    hg_atomic_incr32(na_ofi_class->counters.tx_count);
+#endif
+
     ret = msg_op(
         na_ofi_context->fi_tx, &na_ofi_op_id->info.msg, &na_ofi_op_id->fi_ctx);
     if (ret != NA_SUCCESS) {
@@ -6166,8 +6304,12 @@ na_ofi_msg_send_common(struct na_ofi_class *na_ofi_class,
             na_ofi_op_id->retry_op.msg = msg_op;
             na_ofi_op_retry(
                 na_ofi_context, na_ofi_class->op_retry_timeout, na_ofi_op_id);
-        } else
+        } else {
+#ifdef NA_HAS_DIAG
+            hg_atomic_decr32(na_ofi_class->counters.tx_count);
+#endif
             NA_GOTO_SUBSYS_ERROR_NORET(msg, release, "Could not post msg send");
+        }
     }
 
     return NA_SUCCESS;
@@ -6224,6 +6366,11 @@ na_ofi_msg_recv_common(struct na_ofi_class *na_ofi_class,
         .tag = tag,
         .tag_mask = tag_mask};
 
+#ifdef NA_HAS_DIAG
+    /* Counters */
+    hg_atomic_incr32(na_ofi_class->counters.rx_count);
+#endif
+
     ret = msg_op(
         na_ofi_context->fi_rx, &na_ofi_op_id->info.msg, &na_ofi_op_id->fi_ctx);
     if (ret != NA_SUCCESS) {
@@ -6231,8 +6378,12 @@ na_ofi_msg_recv_common(struct na_ofi_class *na_ofi_class,
             na_ofi_op_id->retry_op.msg = msg_op;
             na_ofi_op_retry(
                 na_ofi_context, na_ofi_class->op_retry_timeout, na_ofi_op_id);
-        } else
+        } else {
+#ifdef NA_HAS_DIAG
+            hg_atomic_decr32(na_ofi_class->counters.rx_count);
+#endif
             NA_GOTO_SUBSYS_ERROR_NORET(msg, release, "Could not post msg recv");
+        }
     }
 
     return NA_SUCCESS;
@@ -6620,6 +6771,11 @@ na_ofi_rma_common(struct na_ofi_class *na_ofi_class, na_context_t *context,
                                   NA_OFI_SEP_RX_CTX_BITS)
                             : na_ofi_addr->fi_addr;
 
+#ifdef NA_HAS_DIAG
+    /* Counters */
+    hg_atomic_incr32(na_ofi_class->counters.rma_count);
+#endif
+
     /* Post the OFI RMA operation */
     ret =
         na_ofi_rma_post(na_ofi_context->fi_tx, rma_info, &na_ofi_op_id->fi_ctx);
@@ -6628,8 +6784,12 @@ na_ofi_rma_common(struct na_ofi_class *na_ofi_class, na_context_t *context,
             na_ofi_op_id->retry_op.rma = na_ofi_rma_post;
             na_ofi_op_retry(
                 na_ofi_context, na_ofi_class->op_retry_timeout, na_ofi_op_id);
-        } else
+        } else {
+#ifdef NA_HAS_DIAG
+            hg_atomic_decr32(na_ofi_class->counters.rma_count);
+#endif
             NA_GOTO_SUBSYS_ERROR_NORET(rma, release, "Could not post RMA op");
+        }
     }
 
     return NA_SUCCESS;
@@ -6991,6 +7151,10 @@ na_ofi_cq_process_canceled(const struct na_ofi_class *na_ofi_class,
             cq_err->err, fi_strerror(cq_err->err), (void *) na_ofi_op_id,
             na_cb_type_to_string(na_ofi_op_id->type));
 
+#ifdef NA_HAS_DIAG
+    na_ofi_cq_process_counters(na_ofi_op_id);
+#endif
+
     /* When tearing down connections, it is possible that operations will be
     canceled by libfabric itself.
     NA_CHECK_SUBSYS_WARNING(op,
@@ -7014,6 +7178,10 @@ na_ofi_cq_process_canceled(const struct na_ofi_class *na_ofi_class,
             &na_ofi_op_id->completion_data->callback_info.info
                 .multi_recv_unexpected,
             complete);
+#ifdef NA_HAS_DIAG
+        if (complete)
+            hg_atomic_decr32(na_ofi_class->counters.rx_count);
+#endif
     } else
         complete = true;
 
@@ -7151,6 +7319,10 @@ na_ofi_cq_process_error(
         NA_OFI_OP_CANCELED)
         return NA_SUCCESS; /* already handled */
 
+#ifdef NA_HAS_DIAG
+    na_ofi_cq_process_counters(na_ofi_op_id);
+#endif
+
     /* Abort other retries if peer is unreachable */
     if (na_ret == NA_HOSTUNREACH && na_ofi_op_id->addr)
         na_ofi_op_retry_abort_addr(na_ofi_op_id->na_ofi_context,
@@ -7172,6 +7344,10 @@ na_ofi_cq_process_error(
             &na_ofi_op_id->completion_data->callback_info.info
                 .multi_recv_unexpected,
             complete);
+#ifdef NA_HAS_DIAG
+        if (complete)
+            hg_atomic_decr32(na_ofi_class->counters.rx_count);
+#endif
     } else
         complete = true;
 
@@ -7346,6 +7522,10 @@ na_ofi_cq_process_event(struct na_ofi_class *na_ofi_class,
         cq_event->op_context, cq_event->flags, cq_event->len, cq_event->buf,
         cq_event->data, cq_event->tag);
 
+#ifdef NA_HAS_DIAG
+    na_ofi_cq_process_counters(na_ofi_op_id);
+#endif
+
     switch (na_ofi_op_id->type) {
         case NA_CB_RECV_UNEXPECTED:
             /* Default to cq_event->tag for backward compatibility */
@@ -7361,6 +7541,10 @@ na_ofi_cq_process_event(struct na_ofi_class *na_ofi_class,
             break;
         case NA_CB_MULTI_RECV_UNEXPECTED:
             complete = cq_event->flags & FI_MULTI_RECV;
+#ifdef HG_HAS_DIAG
+            if (complete)
+                hg_atomic_decr32(na_ofi_class->counters.rx_count);
+#endif
 
             ret = na_ofi_cq_process_multi_recv_unexpected(na_ofi_class,
                 &na_ofi_op_id->info.msg,
@@ -7628,6 +7812,10 @@ na_ofi_cq_process_retries(
             NA_LOG_SUBSYS_ERROR(op, "retry operation of %p (%s) failed",
                 (void *) na_ofi_op_id, na_cb_type_to_string(cb_type));
 
+#ifdef NA_HAS_DIAG
+            na_ofi_cq_process_counters(na_ofi_op_id);
+#endif
+
             /* Force internal completion in error mode */
             hg_atomic_or32(&na_ofi_op_id->status, NA_OFI_OP_ERRORED);
             na_ofi_op_id->complete(na_ofi_op_id, true, ret);
@@ -7690,6 +7878,32 @@ na_ofi_op_retry_abort_addr(
     hg_thread_spin_unlock(&op_queue->lock);
 }
 
+/*---------------------------------------------------------------------------*/
+#ifdef NA_HAS_DIAG
+static void
+na_ofi_cq_process_counters(struct na_ofi_op_id *na_ofi_op_id)
+{
+    switch (na_ofi_op_id->type) {
+        case NA_CB_RECV_UNEXPECTED:
+        case NA_CB_RECV_EXPECTED:
+            hg_atomic_decr32(na_ofi_op_id->na_ofi_class->counters.rx_count);
+            break;
+        case NA_CB_SEND_UNEXPECTED:
+        case NA_CB_SEND_EXPECTED:
+            hg_atomic_decr32(na_ofi_op_id->na_ofi_class->counters.tx_count);
+            break;
+        case NA_CB_PUT:
+        case NA_CB_GET:
+            hg_atomic_decr32(na_ofi_op_id->na_ofi_class->counters.rma_count);
+            break;
+        case NA_CB_MULTI_RECV_UNEXPECTED:
+        /* TODO currently treated outside of switch */
+        default:
+            break;
+    }
+}
+#endif
+
 /*---------------------------------------------------------------------------*/
 static NA_INLINE void
 na_ofi_op_complete_single(struct na_ofi_op_id *na_ofi_op_id,
@@ -7711,6 +7925,9 @@ na_ofi_op_complete_single(struct na_ofi_op_id *na_ofi_op_id,
     completion_data->plugin_callback = na_ofi_op_release_single;
 
     NA_LOG_SUBSYS_DEBUG(op, "Adding completion data to queue");
+#ifdef NA_HAS_DIAG
+    hg_atomic_incr32(na_ofi_op_id->na_ofi_class->counters.cq_count);
+#endif
 
     /* Add OP to NA completion queue */
     na_cb_completion_add(
@@ -7728,6 +7945,9 @@ na_ofi_op_release_single(void *arg)
             (!(hg_atomic_get32(&na_ofi_op_id->status) & NA_OFI_OP_COMPLETED)),
         "Releasing resources from an uncompleted operation");
 
+#ifdef NA_HAS_DIAG
+    hg_atomic_decr32(na_ofi_op_id->na_ofi_class->counters.cq_count);
+#endif
     if (na_ofi_op_id->addr) {
         na_ofi_addr_ref_decr(na_ofi_op_id->addr);
         na_ofi_op_id->addr = NULL;
@@ -7775,6 +7995,10 @@ na_ofi_op_complete_multi(
         op, na_ofi_op_id->completion_data == NULL, error, "Queue is full");
 
     NA_LOG_SUBSYS_DEBUG(op, "Adding completion data to queue");
+#ifdef NA_HAS_DIAG
+    hg_atomic_incr32(na_ofi_op_id->na_ofi_class->counters.cq_count);
+#endif
+
     /* Add OP to NA completion queue */
     na_cb_completion_add(
         na_ofi_op_id->na_ofi_context->context, completion_data);
@@ -7789,6 +8013,9 @@ na_ofi_op_release_multi(void *arg)
 {
     struct na_ofi_op_id *na_ofi_op_id = (struct na_ofi_op_id *) arg;
 
+#ifdef NA_HAS_DIAG
+    hg_atomic_decr32(na_ofi_op_id->na_ofi_class->counters.cq_count);
+#endif
     na_ofi_completion_multi_pop(&na_ofi_op_id->completion_data_storage.multi);
 }
 
@@ -8230,15 +8457,15 @@ na_ofi_initialize(
 
     /* Set/check optional features */
     if ((na_ofi_prov_extra_caps[prov_type] & FI_MULTI_RECV) &&
-        (na_ofi_class->msg_recv_unexpected == na_ofi_msg_recv)) {
+        (na_ofi_class->ops.msg_recv_unexpected == na_ofi_msg_recv)) {
         NA_CHECK_SUBSYS_ERROR(cls,
             !(na_ofi_class->fi_info->caps & FI_MULTI_RECV), error, ret,
             NA_PROTONOSUPPORT, "FI_MULTI_RECV is not supported by provider");
         na_ofi_class->opt_features |= NA_OPT_MULTI_RECV;
     }
-    na_ofi_class->cq_poll = (na_ofi_class->fi_info->caps & FI_SOURCE_ERR)
-                                ? na_ofi_cq_poll_fi_source
-                                : na_ofi_cq_poll_no_source;
+    na_ofi_class->ops.cq_poll = (na_ofi_class->fi_info->caps & FI_SOURCE_ERR)
+                                    ? na_ofi_cq_poll_fi_source
+                                    : na_ofi_cq_poll_no_source;
 
     /* Open fabric */
     ret = na_ofi_fabric_open(
@@ -8959,8 +9186,8 @@ na_ofi_msg_send_unexpected(na_class_t *na_class, na_context_t *context,
 {
     return na_ofi_msg_send_common(NA_OFI_CLASS(na_class),
         NA_OFI_CONTEXT(context), NA_CB_SEND_UNEXPECTED, callback, arg,
-        NA_OFI_CLASS(na_class)->msg_send_unexpected,
-        NA_OFI_CLASS(na_class)->msg_send_unexpected_string, buf, buf_size,
+        NA_OFI_CLASS(na_class)->ops.msg_send_unexpected,
+        NA_OFI_CLASS(na_class)->ops.msg_send_unexpected_string, buf, buf_size,
         NA_OFI_CLASS(na_class)->endpoint->unexpected_msg_size_max,
         (struct na_ofi_msg_buf_handle *) plugin_data,
         (struct na_ofi_addr *) dest_addr, dest_id,
@@ -8975,8 +9202,8 @@ na_ofi_msg_recv_unexpected(na_class_t *na_class, na_context_t *context,
 {
     return na_ofi_msg_recv_common(NA_OFI_CLASS(na_class),
         NA_OFI_CONTEXT(context), NA_CB_RECV_UNEXPECTED, callback, arg,
-        NA_OFI_CLASS(na_class)->msg_recv_unexpected,
-        NA_OFI_CLASS(na_class)->msg_recv_unexpected_string, buf, buf_size,
+        NA_OFI_CLASS(na_class)->ops.msg_recv_unexpected,
+        NA_OFI_CLASS(na_class)->ops.msg_recv_unexpected_string, buf, buf_size,
         NA_OFI_CLASS(na_class)->endpoint->unexpected_msg_size_max,
         (struct na_ofi_msg_buf_handle *) plugin_data, NULL, 0,
         NA_OFI_UNEXPECTED_TAG, NA_OFI_TAG_MASK, (struct na_ofi_op_id *) op_id);
@@ -9027,9 +9254,17 @@ na_ofi_msg_multi_recv_unexpected(na_class_t *na_class, na_context_t *context,
         .tag = 0 /* unused */,
         .tag_mask = 0 /* unused */};
 
+#ifdef NA_HAS_DIAG
+    /* Counters */
+    hg_atomic_incr32(na_ofi_class->counters.rx_count);
+#endif
+
     ret = na_ofi_msg_multi_recv(
         na_ofi_context->fi_rx, &na_ofi_op_id->info.msg, &na_ofi_op_id->fi_ctx);
     if (ret != NA_SUCCESS) {
+#ifdef NA_HAS_DIAG
+        hg_atomic_decr32(na_ofi_class->counters.rx_count);
+#endif
         if (ret == NA_AGAIN) {
             na_ofi_op_id->retry_op.msg = na_ofi_msg_multi_recv;
             na_ofi_op_retry(
@@ -9061,8 +9296,8 @@ na_ofi_msg_send_expected(na_class_t *na_class, na_context_t *context,
 {
     return na_ofi_msg_send_common(NA_OFI_CLASS(na_class),
         NA_OFI_CONTEXT(context), NA_CB_SEND_EXPECTED, callback, arg,
-        NA_OFI_CLASS(na_class)->msg_send_expected,
-        NA_OFI_CLASS(na_class)->msg_send_expected_string, buf, buf_size,
+        NA_OFI_CLASS(na_class)->ops.msg_send_expected,
+        NA_OFI_CLASS(na_class)->ops.msg_send_expected_string, buf, buf_size,
         NA_OFI_CLASS(na_class)->endpoint->expected_msg_size_max,
         (struct na_ofi_msg_buf_handle *) plugin_data,
         (struct na_ofi_addr *) dest_addr, dest_id, (uint64_t) tag,
@@ -9077,8 +9312,8 @@ na_ofi_msg_recv_expected(na_class_t *na_class, na_context_t *context,
 {
     return na_ofi_msg_recv_common(NA_OFI_CLASS(na_class),
         NA_OFI_CONTEXT(context), NA_CB_RECV_EXPECTED, callback, arg,
-        NA_OFI_CLASS(na_class)->msg_recv_expected,
-        NA_OFI_CLASS(na_class)->msg_recv_expected_string, buf, buf_size,
+        NA_OFI_CLASS(na_class)->ops.msg_recv_expected,
+        NA_OFI_CLASS(na_class)->ops.msg_recv_expected_string, buf, buf_size,
         NA_OFI_CLASS(na_class)->endpoint->expected_msg_size_max,
         (struct na_ofi_msg_buf_handle *) plugin_data,
         (struct na_ofi_addr *) source_addr, source_id, (uint64_t) tag, 0,
@@ -9214,7 +9449,11 @@ na_ofi_mem_register(na_class_t *na_class, na_mem_handle_t *mem_handle,
         (struct na_ofi_mem_handle *) mem_handle;
     struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     const struct fi_info *fi_info = NA_OFI_CLASS(na_class)->fi_info;
-    int32_t mr_cnt = hg_atomic_get32(&domain->mr_reg_count);
+#ifdef NA_HAS_DIAG
+    int32_t mr_cnt = hg_atomic_get32(NA_OFI_CLASS(na_class)->counters.mr_count);
+#else
+    int32_t mr_cnt = -1;
+#endif
     struct fi_mr_attr fi_mr_attr = {
         .mr_iov = NA_OFI_IOV(
             na_ofi_mem_handle->desc.iov, na_ofi_mem_handle->desc.info.iovcnt),
@@ -9283,7 +9522,9 @@ na_ofi_mem_register(na_class_t *na_class, na_mem_handle_t *mem_handle,
         fi_mr_attr.mr_iov[0].iov_base, fi_mr_attr.mr_iov[0].iov_len,
         fi_mr_attr.iov_count, fi_mr_attr.access, fi_mr_attr.iface,
         fi_mr_attr.requested_key, rc, fi_strerror(-rc), mr_cnt);
-    mr_cnt = hg_atomic_incr32(&domain->mr_reg_count);
+#ifdef NA_HAS_DIAG
+    mr_cnt = hg_atomic_incr32(NA_OFI_CLASS(na_class)->counters.mr_count);
+#endif
 
     /* Attach MR to endpoint when provider requests it */
     if (fi_info->domain_attr->mr_mode & FI_MR_ENDPOINT) {
@@ -9327,7 +9568,9 @@ na_ofi_mem_register(na_class_t *na_class, na_mem_handle_t *mem_handle,
 error:
     if (na_ofi_mem_handle->fi_mr) {
         (void) fi_close(&na_ofi_mem_handle->fi_mr->fid);
-        hg_atomic_decr32(&domain->mr_reg_count);
+#ifdef NA_HAS_DIAG
+        hg_atomic_decr32(NA_OFI_CLASS(na_class)->counters.mr_count);
+#endif
     }
     return ret;
 }
@@ -9336,7 +9579,6 @@ error:
 static na_return_t
 na_ofi_mem_deregister(na_class_t *na_class, na_mem_handle_t *mem_handle)
 {
-    struct na_ofi_domain *domain = NA_OFI_CLASS(na_class)->domain;
     struct na_ofi_mem_handle *na_ofi_mem_handle =
         (struct na_ofi_mem_handle *) mem_handle;
     na_return_t ret;
@@ -9344,14 +9586,18 @@ na_ofi_mem_deregister(na_class_t *na_class, na_mem_handle_t *mem_handle)
 
     /* close MR handle */
     if (na_ofi_mem_handle->fi_mr != NULL) {
-        int32_t NA_DEBUG_LOG_USED mr_cnt;
+        int32_t NA_DEBUG_LOG_USED mr_cnt = -1;
         const struct iovec NA_DEBUG_LOG_USED *mr_iov = NA_OFI_IOV(
             na_ofi_mem_handle->desc.iov, na_ofi_mem_handle->desc.info.iovcnt);
 
         rc = fi_close(&na_ofi_mem_handle->fi_mr->fid);
         NA_CHECK_SUBSYS_ERROR(mem, rc != 0, error, ret, na_ofi_errno_to_na(-rc),
             "fi_close() mr_hdl failed, rc: %d (%s)", rc, fi_strerror(-rc));
-        mr_cnt = hg_atomic_decr32(&domain->mr_reg_count);
+#ifdef NA_HAS_DIAG
+        mr_cnt = hg_atomic_decr32(NA_OFI_CLASS(na_class)->counters.mr_count);
+#else
+        (void) na_class;
+#endif
 
         NA_LOG_SUBSYS_DEBUG(mem,
             "Deregistered memory region: mr_iov[0].iov_base=%p, "
@@ -9575,7 +9821,7 @@ na_ofi_poll(na_class_t *na_class, na_context_t *context, unsigned int *count_p)
         return NA_SUCCESS;
 
     /* Read from CQ and process events */
-    ret = na_ofi_class->cq_poll(na_ofi_class, na_ofi_context, &count);
+    ret = na_ofi_class->ops.cq_poll(na_ofi_class, na_ofi_context, &count);
     NA_CHECK_SUBSYS_NA_ERROR(poll, error, ret, "Could not poll context CQ");
 
     /* Attempt to process retries */
diff --git a/src/util/mercury_dlog.c b/src/util/mercury_dlog.c
index 042a0157..fbdc114f 100644
--- a/src/util/mercury_dlog.c
+++ b/src/util/mercury_dlog.c
@@ -138,6 +138,40 @@ hg_dlog_mkcount64(struct hg_dlog *d, hg_atomic_int64_t **cptr, const char *name,
     hg_thread_mutex_unlock(&d->dlock);
 }
 
+/*---------------------------------------------------------------------------*/
+void
+hg_dlog_rmcount32(struct hg_dlog *d, hg_atomic_int32_t *cptr)
+{
+    struct hg_dlog_dcount32 *dcnt;
+
+    hg_thread_mutex_lock(&d->dlock);
+    TAILQ_FOREACH (dcnt, &d->cnts32, l) {
+        if (&dcnt->c == cptr) {
+            TAILQ_REMOVE(&d->cnts32, dcnt, l);
+            free(dcnt);
+            break;
+        }
+    }
+    hg_thread_mutex_unlock(&d->dlock);
+}
+
+/*---------------------------------------------------------------------------*/
+void
+hg_dlog_rmcount64(struct hg_dlog *d, hg_atomic_int64_t *cptr)
+{
+    struct hg_dlog_dcount64 *dcnt;
+
+    hg_thread_mutex_lock(&d->dlock);
+    TAILQ_FOREACH (dcnt, &d->cnts64, l) {
+        if (&dcnt->c == cptr) {
+            TAILQ_REMOVE(&d->cnts64, dcnt, l);
+            free(dcnt);
+            break;
+        }
+    }
+    hg_thread_mutex_unlock(&d->dlock);
+}
+
 /*---------------------------------------------------------------------------*/
 unsigned int
 hg_dlog_addlog(struct hg_dlog *d, const char *file, unsigned int line,
@@ -210,8 +244,9 @@ hg_dlog_dump(struct hg_dlog *d, int (*log_func)(FILE *, const char *, ...),
             "### (%s) debug log summary\n"
             "### ----------------------\n",
             (d->dlog_magic + strlen(HG_DLOG_STDMAGIC)));
-        if (!TAILQ_EMPTY(&d->cnts32) && !TAILQ_EMPTY(&d->cnts64)) {
+        if (!TAILQ_EMPTY(&d->cnts32) || !TAILQ_EMPTY(&d->cnts64)) {
             log_func(stream, "# Counters\n");
+
             TAILQ_FOREACH (dc32, &d->cnts32, l) {
                 log_func(stream, "# %s: %" PRId32 " [%s]\n", dc32->name,
                     hg_atomic_get32(&dc32->c), dc32->descr);
diff --git a/src/util/mercury_dlog.h b/src/util/mercury_dlog.h
index 88944b05..43c30a4f 100644
--- a/src/util/mercury_dlog.h
+++ b/src/util/mercury_dlog.h
@@ -155,6 +155,15 @@ HG_UTIL_PUBLIC void
 hg_dlog_mkcount32(struct hg_dlog *d, hg_atomic_int32_t **cptr, const char *name,
     const char *descr);
 
+/**
+ * remove a 32-bit counter from a dlog.
+ *
+ * \param d [IN]                dlog to remove the counter from
+ * \param cptr [IN]             pointer to counter to remove
+ */
+HG_UTIL_PUBLIC void
+hg_dlog_rmcount32(struct hg_dlog *d, hg_atomic_int32_t *cptr);
+
 /**
  * make a named atomic64 counter in a dlog and return a pointer to
  * it.  we use the dlock to ensure a counter under a given name only
@@ -178,6 +187,15 @@ HG_UTIL_PUBLIC void
 hg_dlog_mkcount64(struct hg_dlog *d, hg_atomic_int64_t **cptr, const char *name,
     const char *descr);
 
+/**
+ * remove a 64-bit counter from a dlog.
+ *
+ * \param d [IN]                dlog to remove the counter from
+ * \param cptr [IN]             pointer to counter to remove
+ */
+HG_UTIL_PUBLIC void
+hg_dlog_rmcount64(struct hg_dlog *d, hg_atomic_int64_t *cptr);
+
 /**
  * attempt to add a log record to a dlog.  the id and msg should point
  * to static strings that are valid throughout the life of the program
diff --git a/src/util/mercury_log.c b/src/util/mercury_log.c
index 483922bf..2fc13548 100644
--- a/src/util/mercury_log.c
+++ b/src/util/mercury_log.c
@@ -500,16 +500,9 @@ hg_log_outlet_deregister(struct hg_log_outlet *hg_log_outlet)
 
     if (hg_log_outlet->debug_log &&
         !(hg_log_outlet->parent &&
-            hg_log_outlet->parent->debug_log == hg_log_outlet->debug_log)) {
-        if (hg_log_outlet->level >= HG_LOG_LEVEL_MIN_DEBUG) {
-            FILE *stream = hg_log_streams_g[hg_log_outlet->level]
-                               ? hg_log_streams_g[hg_log_outlet->level]
-                               : *hg_log_std_streams_g[hg_log_outlet->level];
-            hg_dlog_dump_counters(
-                hg_log_outlet->debug_log, hg_log_func_g, stream, 0);
-        }
+            hg_log_outlet->parent->debug_log == hg_log_outlet->debug_log))
         hg_dlog_free(hg_log_outlet->debug_log);
-    }
+
     STAILQ_REMOVE(&hg_log_outlets_g, hg_log_outlet, hg_log_outlet, entry);
     hg_log_outlet->registered = false;
 }
@@ -593,7 +586,8 @@ hg_log_vwrite(struct hg_log_outlet *hg_log_outlet, enum hg_log_level log_level,
         no_return ? "" : "\n");
 #endif
 
-    if (log_level == HG_LOG_LEVEL_ERROR && hg_log_outlet->debug_log &&
+    if ((log_level == HG_LOG_LEVEL_ERROR || log_level == HG_LOG_LEVEL_FATAL) &&
+        hg_log_outlet->debug_log &&
         hg_log_outlet->level >= HG_LOG_LEVEL_MIN_DEBUG) {
         hg_dlog_dump(hg_log_outlet->debug_log, hg_log_func_g, stream, 0);
         hg_dlog_resetlog(hg_log_outlet->debug_log);
diff --git a/src/util/mercury_log.h b/src/util/mercury_log.h
index ceba0c7a..1ed01429 100644
--- a/src/util/mercury_log.h
+++ b/src/util/mercury_log.h
@@ -308,11 +308,19 @@
     hg_dlog_mkcount32(HG_LOG_OUTLET(name).debug_log, counter_ptr,              \
         counter_name, counter_desc)
 
+/* HG_LOG_DEL_COUNTER32: delete 32-bit debug log counter */
+#define HG_LOG_DEL_COUNTER32(name, counter_ptr)                                \
+    hg_dlog_rmcount32(HG_LOG_OUTLET(name).debug_log, counter_ptr)
+
 /* HG_LOG_ADD_COUNTER64: add 64-bit debug log counter */
 #define HG_LOG_ADD_COUNTER64(name, counter_ptr, counter_name, counter_desc)    \
     hg_dlog_mkcount64(HG_LOG_OUTLET(name).debug_log, counter_ptr,              \
         counter_name, counter_desc)
 
+/* HG_LOG_DEL_COUNTER64: delete 64-bit debug log counter */
+#define HG_LOG_DEL_COUNTER64(name, counter_ptr)                                \
+    hg_dlog_rmcount64(HG_LOG_OUTLET(name).debug_log, counter_ptr)
+
 /*************************************/
 /* Public Type and Struct Definition */
 /*************************************/
diff --git a/src/util/version.txt b/src/util/version.txt
index fcdb2e10..ee74734a 100644
--- a/src/util/version.txt
+++ b/src/util/version.txt
@@ -1 +1 @@
-4.0.0
+4.1.0
-- 
2.52.0

